from copy import deepcopy
import lark
from lark import Lark, Tree, Token
from lark.visitors import Interpreter

from symbol_table_creation_attemp import symbol_table, text, just_class, set_inheritance, ClassTreeSetter, \
    class_type_objects, class_table, Function, ImplicitThis
from symbol_table_creation_attemp import symbol_table_objects, function_objects, \
    function_table, grammar, SymbolTableMaker, Type


def pop_scope(scope):
    scopes = scope.split('/')
    scopes.pop()
    parent_scope = '/'.join(scopes)
    return parent_scope


def tab(code) -> str:
    codes = code.split('\n')
    if len(codes[0]) == 0:
        codes = codes[1:]
    remove = 0
    for char in codes[0]:
        if char == ' ':
            remove += 1
        else:
            break
    for i in range(len(codes)):
        codes[i] += '\n'
        line = codes[i]
        if line[:remove] == ' ' * remove:
            codes[i] = line[remove:]
    if codes[-1][-1] != '\n':
        codes[-1][-1] += '\n'
    return ''.join(codes)


class Types:
    BOOL = 'bool'
    INT = 'int'
    STRING = 'string'
    DOUBLE = 'double'


def cnt():
    CodeGenerator.LabelCnt += 1
    return CodeGenerator.LabelCnt


def cast_cgen():
    code = ''
    code += tab(""" # ITOD
             .data
                 .align 2
                 root_itod_ival: .space 4
             .text
                 root_itod:
                 la $t0, root_itod_ival
                 sub $sp, $sp, 8
                 sw $t0, 0($sp)

                 lw $t0, 0($sp)
                 lw $t0, 0($t0)
                 sw $t0, 0($sp)

                 mtc1.d $t0, $f0
                 cvt.d.w $f0, $f0


                 sub $sp, $sp, 8
                 s.d $f0, 0($sp)

                 l.d   $f30, 0($sp)
                 addi $sp, $sp, 8
                 addi $sp, $sp, 8
                 addi $sp, $sp, -8
                 s.d   $f30, 0($sp)
                 jr   $ra
             """)

    code += tab(
        """
        #DTOI
        root_dtoi:
        .data
        .align 2
        root_dtoi_dval: .space 8
        .text
            li $t0, 1
            sub $sp, $sp, 8
            sw $t0, 0($sp)

            la $t0, root_dtoi_dval
            sub $sp, $sp, 8
            sw $t0, 0($sp)
            lw $t0, 0($sp)
            l.d $f0, 0($t0)


            li.d $f6, 0.49999999 # round to nearest integer
            add.d $f0, $f0, $f6

            cvt.w.d $f0,$f0
            mfc1.d $a0,$f0
            sw $a0, 0($sp)


            l.d   $f30, 0($sp)
            addi $sp, $sp, 8
            addi $sp, $sp, 8

            addi $sp, $sp, -8
            s.d   $f30, 0($sp)
            jr   $ra

        """
    )

    code += tab(
        """
        # ceil
        root_ceil__:
        .data
        .align 2
        root_ceil___dval: .space 8
        .text
            li $t0, 1
            sub $sp, $sp, 8
            sw $t0, 0($sp)

            la $t0, root_ceil___dval
            sub $sp, $sp, 8
            sw $t0, 0($sp)
            lw $t0, 0($sp)
            l.d $f0, 0($t0)


            # li.d $f6, 0.49999999 # round to nearest integer
            # add.d $f0, $f0, $f6

            cvt.w.d $f0,$f0
            mfc1.d $a0,$f0
            sw $a0, 0($sp)


            l.d   $f30, 0($sp)
            addi $sp, $sp, 8
            addi $sp, $sp, 8

            addi $sp, $sp, -8
            s.d   $f30, 0($sp)
            jr   $ra

        """
    )

    code += tab(  # generated by cgen
        """
        .text
        root_itob:
        .data
        .align 2
            root_itob_ival: .space 4
        .text
            la $t0, root_itob_ival
            sub $sp, $sp, 8
            sw $t0, 0($sp)
            lw $t0, 0($sp)
            lw $t0, 0($t0)
            sw $t0, 0($sp)
            li $t0, 0
            sub $sp, $sp, 8
            sw $t0, 0($sp)
            lw $t0, 0($sp)
            lw $t1, 8($sp)
            sne $t2, $t1, $t0
            sw $t2, 8($sp)
            addi $sp, $sp, 8
            l.d   $f30, 0($sp)
            addi $sp, $sp, 8
            addi $sp, $sp, -8
            s.d   $f30, 0($sp)
            jr   $ra
        """
    )
    code += tab(  # generated by cgen
        """
        .text
        root_btoi:
        .data
        .align 2
        root_btoi_bval: .space 4
        .text
        start_btoi_stmt_1:
        start_btoi_stmt_2:
        # if starts here:
        .text
            la $t0, root_btoi_bval
            sub $sp, $sp, 8
            sw $t0, 0($sp)
            lw $t0, 0($sp)
            lw $t0, 0($t0)
            sw $t0, 0($sp)
            lw $a0, 0($sp)
            addi $sp, $sp, 8
            beq $a0, 0, end_btoi_stmt_3
            j  start_btoi_stmt_3
        start_btoi_stmt_3:
        start_btoi_stmt_4:
        start_btoi_stmt_5:
            li $t0, 1
            sub $sp, $sp, 8
            sw $t0, 0($sp)

            l.d   $f30, 0($sp)
            addi $sp, $sp, 8
            addi $sp, $sp, -8
            s.d   $f30, 0($sp)
            jr   $ra
        end_btoi_stmt_5:
        end_btoi_stmt_4:
        end_btoi_stmt_3:
        end_btoi_stmt_2:
        start_btoi_stmt_6:
        .text
            li $t0, 0
            sub $sp, $sp, 8
            sw $t0, 0($sp)

            l.d   $f30, 0($sp)
            addi $sp, $sp, 8
            addi $sp, $sp, -8
            s.d   $f30, 0($sp)
            jr   $ra

        end_btoi_stmt_6:
        end_btoi_stmt_1:
        """
    )
    code += tab("""
    
    .text
    root_print_double__:
    .data
    .align 2
    root_print_double___x: .space 8
    .text
    start_pstmt_1:
    .data
    .align 2
    root_print_double____local_0_xc: .space 8
    
    .text
        l.d  $f0, root_print_double____local_0_xc
        addi $sp, $sp, -8
        s.d  $f0, 0($sp)
    
    .data
    .align 2
    root_print_double____local_0_y: .space 4
    
    .text
        la   $t0, root_print_double____local_0_y
        lw   $t1, 0($t0)
        addi $sp, $sp, -8
        sw   $t1, 0($sp)
    
    start_pstmt_2:
    .text
        la $t0, root_print_double___x
        sub $sp, $sp, 8
        sw $t0, 0($sp)
    
    .text
        la $t0, root_print_double___x
        sub $sp, $sp, 8
        sw $t0, 0($sp)
    
    .text
        lw $t0, 0($sp)
        l.d $f0, 0($t0)
        s.d $f0, 0($sp)
    
    .text
        li.d $f0, 0.0000499999
        sub $sp, $sp, 8
        s.d $f0, 0($sp)
    
    .text
        l.d $f0, 0($sp)
        l.d $f2, 8($sp)
        add.d $f4, $f2, $f0
        s.d $f4, 8($sp)
        addi $sp, $sp, 8
    
    .text
        lw $t0, 8($sp)
        l.d $f0, 0($sp)
        s.d $f0, 0($t0)
        s.d $f0, 8($sp)
        addi $sp, $sp, 8
    
    .text
        addi	$sp, $sp, 8
    
    end_pstmt_2:
    start_pstmt_3:
    .text
        la $t0, root_print_double____local_0_xc
        sub $sp, $sp, 8
        sw $t0, 0($sp)
    
    .text
        la $t0, root_print_double___x
        sub $sp, $sp, 8
        sw $t0, 0($sp)
    
    .text
        lw $t0, 0($sp)
        l.d $f0, 0($t0)
        s.d $f0, 0($sp)
    
    .text
        lw $t0, 8($sp)
        l.d $f0, 0($sp)
        s.d $f0, 0($t0)
        s.d $f0, 8($sp)
        addi $sp, $sp, 8
    
    .text
        addi	$sp, $sp, 8
    
    end_pstmt_3:
    start_pstmt_4:
    .text
        la $t0, root_print_double___x
        sub $sp, $sp, 8
        sw $t0, 0($sp)
    
    .text
        la $t0, root_print_double___x
        sub $sp, $sp, 8
        sw $t0, 0($sp)
    
    .text
        lw $t0, 0($sp)
        l.d $f0, 0($t0)
        s.d $f0, 0($sp)
    
    .text
        lw   $t1, root_itod_ival
        addi $sp, $sp, -8
        sw   $t1, 0($sp)
    
    .text
        l.d  $f0, root_ceil___dval
        addi $sp, $sp, -8
        s.d  $f0, 0($sp)
    
    .text
        la $t0, root_print_double___x
        sub $sp, $sp, 8
        sw $t0, 0($sp)
    
    .text
        lw $t0, 0($sp)
        l.d $f0, 0($t0)
        s.d $f0, 0($sp)
    
    .text
        l.d  $f0, 0($sp)
        s.d  $f0, root_ceil___dval
        addi $sp, $sp, 8
    
    .text
        addi $sp, $sp, -8
        sw   $ra, 0($sp)
        jal root_ceil__
        lw   $t8, 0($sp)
        addi $sp, $sp, 8
        lw   $ra, 0($sp)
        addi $sp, $sp, 8
    
        l.d  $f0, 0($sp)
        addi $sp, $sp, 8
        s.d  $f0, root_ceil___dval
    
        addi $sp, $sp, -8
        sw   $t8, 0($sp)
    # return type is int 0
    .text
        lw   $v0, 0($sp)
        sw   $v0, root_itod_ival
        addi $sp, $sp, 8
    
    .text
        addi $sp, $sp, -8
        sw   $ra, 0($sp)
        jal root_itod
        l.d   $f30, 0($sp)
        addi $sp, $sp, 8
        lw   $ra, 0($sp)
        addi $sp, $sp, 8
    
        lw   $t0, 0($sp)
        addi $sp, $sp, 8
        sw   $t0, root_itod_ival
    
        addi $sp, $sp, -8
        s.d   $f30, 0($sp)
    # return type is double 0
    .text
        l.d $f0, 0($sp)
        l.d $f2, 8($sp)
        sub.d $f4, $f2, $f0
        s.d $f4, 8($sp)
        addi $sp, $sp, 8
    
    .text
        lw $t0, 8($sp)
        l.d $f0, 0($sp)
        s.d $f0, 0($t0)
        s.d $f0, 8($sp)
        addi $sp, $sp, 8
    
    .text
        addi	$sp, $sp, 8
    
    end_pstmt_4:
    start_pstmt_5:
    .text
        la $t0, root_print_double___x
        sub $sp, $sp, 8
        sw $t0, 0($sp)
    
    .text
        la $t0, root_print_double___x
        sub $sp, $sp, 8
        sw $t0, 0($sp)
    
    .text
        lw $t0, 0($sp)
        l.d $f0, 0($t0)
        s.d $f0, 0($sp)
    
    .text
        li.d $f0, 10000.0
        sub $sp, $sp, 8
        s.d $f0, 0($sp)
    
    .text
        l.d      $f0, 0($sp)
        l.d      $f2, 8($sp)
        mul.d    $f4, $f2, $f0
        s.d      $f4, 8($sp)
        addi     $sp, $sp, 8
    
    .text
        lw $t0, 8($sp)
        l.d $f0, 0($sp)
        s.d $f0, 0($t0)
        s.d $f0, 8($sp)
        addi $sp, $sp, 8
    
    .text
        addi	$sp, $sp, 8
    
    end_pstmt_5:
    start_pstmt_6:
    .text
        la $t0, root_print_double____local_0_y
        sub $sp, $sp, 8
        sw $t0, 0($sp)
    
    .text
        l.d  $f0, root_ceil___dval
        addi $sp, $sp, -8
        s.d  $f0, 0($sp)
    
    .text
        la $t0, root_print_double___x
        sub $sp, $sp, 8
        sw $t0, 0($sp)
    
    .text
        lw $t0, 0($sp)
        l.d $f0, 0($t0)
        s.d $f0, 0($sp)
    
    .text
        l.d  $f0, 0($sp)
        s.d  $f0, root_ceil___dval
        addi $sp, $sp, 8
    
    .text
        addi $sp, $sp, -8
        sw   $ra, 0($sp)
        jal root_ceil__
        lw   $t8, 0($sp)
        addi $sp, $sp, 8
        lw   $ra, 0($sp)
        addi $sp, $sp, 8
    
        l.d  $f0, 0($sp)
        addi $sp, $sp, 8
        s.d  $f0, root_ceil___dval
    
        addi $sp, $sp, -8
        sw   $t8, 0($sp)
    # return type is int 0
    .text
        lw $t0, 8($sp)
        lw $t1, 0($sp)
        sw $t1, 0($t0)
        sw $t1, 8($sp)
        addi $sp, $sp, 8
    
    .text
        addi	$sp, $sp, 8
    
    end_pstmt_6:
    start_pstmt_7:
    .text				# While
    .text
        la $t0, root_print_double____local_0_y
        sub $sp, $sp, 8
        sw $t0, 0($sp)
    
    .text
        lw $t0, 0($sp)
        lw $t0, 0($t0)
        sw $t0, 0($sp)
    
    .text
        li $t0, 0
        sub $sp, $sp, 8
        sw $t0, 0($sp)
    
    .text
        lw $t0, 0($sp)
        lw $t1, 8($sp)
        sne $t2, $t1, $t0
        sw $t2, 8($sp)
        addi $sp, $sp, 8
    
    .text
        la $t0, root_print_double____local_0_y
        sub $sp, $sp, 8
        sw $t0, 0($sp)
    
    .text
        lw $t0, 0($sp)
        lw $t0, 0($t0)
        sw $t0, 0($sp)
    
    .text
        li $t0, 10
        sub $sp, $sp, 8
        sw $t0, 0($sp)
    
    .text
        lw $t0, 0($sp)
        lw $t1, 8($sp)
        div $t1, $t0
        mfhi $t2
        sw $t2, 8($sp)
        addi $sp, $sp, 8
    .text
        li $t0, 0
        sub $sp, $sp, 8
        sw $t0, 0($sp)
    
    .text
        lw $t0, 0($sp)
        lw $t1, 8($sp)
        seq $t2, $t1, $t0
        sw $t2, 8($sp)
        addi $sp, $sp, 8
    
    .text
        lw $t0, 0($sp)
        lw $t1, 8($sp)
        and $t2, $t1, $t0
        sw $t2, 8($sp)
        addi $sp, $sp, 8
    
    lw $a0, 0($sp)
    addi $sp, $sp, 8
    beq $a0, 0, end_pstmt_7
            
    start_pstmt_8:
    .text
    start_pstmt_9:
    start_pstmt_10:
    .text
        la $t0, root_print_double____local_0_y
        sub $sp, $sp, 8
        sw $t0, 0($sp)
    
    .text
        la $t0, root_print_double____local_0_y
        sub $sp, $sp, 8
        sw $t0, 0($sp)
    
    .text
        lw $t0, 0($sp)
        lw $t0, 0($t0)
        sw $t0, 0($sp)
    
    .text
        li $t0, 10
        sub $sp, $sp, 8
        sw $t0, 0($sp)
    
    .text
        lw $t0, 0($sp)
        lw $t1, 8($sp)
        div $t2, $t1, $t0
        sw $t2, 8($sp)
        addi $sp, $sp, 8
    
    .text
        lw $t0, 8($sp)
        lw $t1, 0($sp)
        sw $t1, 0($t0)
        sw $t1, 8($sp)
        addi $sp, $sp, 8
    
    .text
        addi	$sp, $sp, 8
    
    end_pstmt_10:
    end_pstmt_9:
    end_pstmt_8:
    j start_pstmt_7
    end_pstmt_7:
    .text
        l.d  $f0, root_ceil___dval
        addi $sp, $sp, -8
        s.d  $f0, 0($sp)
    
    .text
        la $t0, root_print_double____local_0_xc
        sub $sp, $sp, 8
        sw $t0, 0($sp)
    
    .text
        lw $t0, 0($sp)
        l.d $f0, 0($t0)
        s.d $f0, 0($sp)
    
    .text
        l.d  $f0, 0($sp)
        s.d  $f0, root_ceil___dval
        addi $sp, $sp, 8
    
    .text
        addi $sp, $sp, -8
        sw   $ra, 0($sp)
        jal root_ceil__
        lw   $t8, 0($sp)
        addi $sp, $sp, 8
        lw   $ra, 0($sp)
        addi $sp, $sp, 8
    
        l.d  $f0, 0($sp)
        addi $sp, $sp, 8
        s.d  $f0, root_ceil___dval
    
        addi $sp, $sp, -8
        sw   $t8, 0($sp)
    # return type is int 0
    .text
    # Print int
        li $v0, 1
        lw $a0, 0($sp)
        addi $sp, $sp, 8
        syscall             #Print int
    ##
                    
    .data
    .align 2
    __pconst_str__0: .asciiz "."
    .text
        la $t0, __pconst_str__0
        sub $sp, $sp, 8
        sw $t0, 0($sp)
    
    .text
    # Print string
        li $v0, 4
        lw $a0, 0($sp)
        addi $sp, $sp, 8
        syscall             #Print string
    ##
    
    .text
        la $t0, root_print_double____local_0_y
        sub $sp, $sp, 8
        sw $t0, 0($sp)
    
    .text
        lw $t0, 0($sp)
        lw $t0, 0($t0)
        sw $t0, 0($sp)
    
    .text
    # Print int
        li $v0, 1
        lw $a0, 0($sp)
        addi $sp, $sp, 8
        syscall             #Print int
    ##
                    

    
    start_pstmt_11:
    .text
        lw   $t0, 0($sp)
        addi $sp, $sp, 8
        sw   $t0, root_print_double____local_0_y
    
    .text
        l.d  $f0, 0($sp)
        addi $sp, $sp, 8
        s.d  $f0, root_print_double____local_0_xc
    
        jr   $ra
    
    end_ppstmt_11:
    .text
        lw   $t1, 0($sp)
        addi $sp, $sp, 8
        la   $t0, root_print_double____local_0_y
        sw   $t1, 0($t0)
    
    .text
        l.d  $f0, 0($sp)
        addi $sp, $sp, 8
        s.d  $f0, root_print_double____local_0_xc
    
    end_pstmt_1:
    """)
    return code


class CodeGenerator(Interpreter):
    current_scope = 'root'
    block_stmt_counter = 0
    str_const = 0
    LabelCnt = 0
    class_cnt = 0
    """we need a way to store which local_variable do we have in our current scope so that in case of recursive
    call save the prior values of local_vars. protocol of this stack is in the following order:
    - in the entering of a stmt_block we push every variable_decl consist of [full scope name, type]
    - in the exiting of a stmt_block we pop last N elements which N is the number of variable_decl in that stmt_block
    - before return which is equivalent to 'jr $ra', we pop last N elements which N is number of variable_decl we have
        seen until now"""
    stack_local_params = []
    """this stack save number of variable_decl we have seen until now. protocol of this stack is in the following order:
    - last element ++1 when entering a new stmt_block for each variable_decl
    - last element --N when exiting a stmt_block which N is the number of variable_decl in that stmt_block
    - before every function call which is equivalent to 'jal f_label', we append 0 to stack
    - before every return which is equivalent to 'jr $ra', we pop last element of stack   
    """
    stack_local_params_count = [0]

    def __init__(self):
        super().__init__()
        self.expr_types = []
        self.stmt_labels = []
        self.loop_labels = []
        self.last_type = None

    def start(self, tree):
        return ''.join(self.visit_children(tree))

    def decl(self, tree):
        code = ''
        for decl in tree.children:
            if decl.data == 'variable_decl' or decl.data == 'function_decl':
                code += self.visit(decl)
            elif decl.data == 'class_decl':
                code += self.visit(decl)
        return code

    def class_inst(self, tree):
        class_name = tree.children[0].value
        class_obj = class_type_objects[class_table[class_name]]
        size = 8 + len(class_obj.variables) * 8
        self.expr_types.append(Type(name=class_name))
        code = ''
        code += '.text\n'
        code += '\tli $a0, {}\n'.format(size)
        code += '\tli $v0, 9\n'
        code += '\tsyscall\n'
        code += '\tlw $t0, {}\n'.format(class_name + '_vtable')
        code += '\tsw $t0, 0($v0)\n'
        code += '\taddi $sp, $sp, -8\n'
        code += '\tsw $v0, 0($sp)\n'
        return code

    def function_decl(self, tree):
        # print(tree)
        # exit(0)
        code = ''
        if len(tree.children) == 4:
            ident = tree.children[1]
            formals = tree.children[2]
            stmt_block = tree.children[3]
        else:
            ident = tree.children[0]
            formals = tree.children[1]
            stmt_block = tree.children[2]

        if ident == 'main':
            code += (
                '.text\n'
                '__strcmp__:\n'
                '\tlb $t0, 0($a0)\n'
                '\tlb $t1, 0($a1)\n'
                '\tbne $t0, $t1, __NE__\n'
                '\tbne $t0, $zero, __cont__\n'
                '\tli $v0, 1\n'
                '\tjr $ra\n'
                '__cont__:\n'
                '\taddi $a0, $a0, 1\n'
                '\taddi $a1, $a1, 1\n'
                '\tj __strcmp__\n'
                '__NE__:\n'
                '\tli $v0, 0\n'
                '\tjr $ra\n\n'
                '.data\n'
                '.align 2\n'
                '\ttrue: .asciiz "true"\n'
                '\tfalse: .asciiz "false"\n'
                '\tpconst10000: .double 10000.0\n'
                '\tnw: .asciiz "\\n"\n'
                '\t__const_0_5__: .double 0.5\n'
            )
            code += cast_cgen()
            code += ('.text\n'
                     'main:\n')
            for cl in range(len(class_table)):
                code += '\tjal __init__vtable_{}\n'.format(cl)
            code += '\tla\t$ra,__end__\n'
        else:
            code += '.text\n{}:\n'.format((self.current_scope + '/' + ident).replace('/', '_'))

        self.current_scope += "/" + ident.value
        code += self.visit(formals)

        self.current_scope += "/_local"
        self.stack_local_params_count.append(0)

        if ident != 'main':
            return_stmt = Tree(data='stmt', children=[Tree(data='return_stmt', children=[])])
            stmt_block._meta = return_stmt

        code += self.visit(stmt_block)

        local_var_count = self.stack_local_params_count[-1]
        self.stack_local_params = self.stack_local_params[:-local_var_count]
        self.stack_local_params_count.pop()
        self.current_scope = pop_scope(self.current_scope)  # pop _local
        self.current_scope = pop_scope(self.current_scope)  # pop formals
        # code += "jr $ra\n"

        if ident == 'main':
            code += '.text\n'
            code += '__end__:\n'
            code += '\tli $v0, 10\t\t\t#exit\n'
            code += '\tsyscall\n'
        return code

    def formals(self, tree):
        code = ''
        for variable in tree.children:
            formal_name = variable.children[1].value
            formal_type = symbol_table_objects[symbol_table[(self.current_scope, formal_name)]].type
            code += '.data\n'
            code += '.align 2\n'
            if formal_type.name == 'double' and formal_type.dimension == 0:
                code += '{}: .space 8\n'.format((self.current_scope + "/" + formal_name).replace("/", "_"))
            else:
                code += '{}: .space 4\n'.format((self.current_scope + "/" + formal_name).replace("/", "_"))
        return code

    def stmt_block(self, tree):
        self.current_scope += "/" + str(self.block_stmt_counter)
        self.block_stmt_counter += 1
        code = ''
        stmt_id = cnt()
        store_len = len(self.stmt_labels)
        code += '.text\nstart_stmt_{}:\n'.format(stmt_id)
        # print(' ->', tree._meta, type(tree._meta), type(tree._meta) == lark.tree.Tree)

        if type(tree._meta) == lark.tree.Tree:
            return_stmt = tree._meta
            tree.children.append(return_stmt)

        for child in tree.children:
            if child.data == 'variable_decl':
                code += self.visit(child)
                self.stack_local_params_count[-1] += 1
                variable_name = child.children[0].children[1].value
                variable_type = symbol_table_objects[
                    symbol_table[(self.current_scope, variable_name)]].type  # TODO is current_scope set?
                self.stack_local_params.append(
                    [self.current_scope + "/" + variable_name, variable_type])  # todo must review
                code += '.text\n'
                if variable_type.name == 'double' and variable_type.dimension == 0:
                    code += '\tl.d  $f0, {}\n'.format((self.current_scope + "/" + variable_name).replace("/", "_"))
                    code += '\taddi $sp, $sp, -8\n'
                    code += '\ts.d  $f0, 0($sp)\n\n'
                else:
                    code += '\tla   $t0, {}\n'.format((self.current_scope + "/" + variable_name).replace("/", "_"))
                    code += '\tlw   $t1, 0($t0)\n'
                    code += '\taddi $sp, $sp, -8\n'
                    code += '\tsw   $t1, 0($sp)\n\n'
            else:
                code += self.visit(child)

        # pop declared variables in this scope
        for child in reversed(tree.children):
            if child.data == 'variable_decl':
                self.stack_local_params_count[-1] -= 1
                variable_name = child.children[0].children[1].value
                variable_type = symbol_table_objects[symbol_table[(self.current_scope, variable_name)]].type
                self.stack_local_params.pop()  # todo must review
                code += '.text\n'
                if variable_type.name == 'double' and variable_type.dimension == 0:
                    code += '\tl.d  $f0, 0($sp)\n'
                    code += '\taddi $sp, $sp, 8\n'
                    code += '\ts.d  $f0, {}\n\n'.format((self.current_scope + "/" + variable_name).replace("/", "_"))
                else:
                    code += '\tlw   $t1, 0($sp)\n'
                    code += '\taddi $sp, $sp, 8\n'
                    code += '\tla   $t0, {}\n'.format((self.current_scope + "/" + variable_name).replace("/", "_"))
                    code += '\tsw   $t1, 0($t0)\n\n'

        code += 'end_stmt_{}:\n'.format(stmt_id)
        self.stmt_labels = self.stmt_labels[:store_len]
        self.stmt_labels.append(stmt_id)
        self.current_scope = pop_scope(self.current_scope)
        return code
        # todo must review by Sir Sadegh

    def stmt(self, tree):
        child = tree.children[0]
        store_len = len(self.stmt_labels)
        code = ''
        if child.data == 'for_stmt':
            if child.children[0].data == 'ass':
                code += self.visit(child.children[0])
                code += '\taddi $sp, $sp, 8\n'

        stmt_id = cnt()
        code += ('start_stmt_{}:\n'.format(stmt_id))

        child._meta = stmt_id

        if child.data == 'if_stmt':
            code += self.visit(child)
        elif child.data == 'while_stmt':
            code += self.visit(child)
        elif child.data == 'for_stmt':
            code += self.visit(child)
        elif child.data == 'stmt_block':
            code += self.visit(child)
        elif child.data == 'break_stmt':  # there is a problem with it !
            code += self.visit(child)
        elif child.data == 'return_stmt':
            # raise Exception()
            code += self.visit(child)
            # todo implement for class methods
            # todo is it really done?
            func_name = ''
            if '__class__' in self.current_scope:
                func_name = self.current_scope.split('/')[2]
                class_name = self.current_scope.split('/')[1][9:]
                funct = class_type_objects[class_table[class_name]].find_function(func_name)
            else:
                func_name = self.current_scope.split('/')[1]
                funct = function_objects[function_table[func_name]]

            if funct.return_type.name == 'double' and funct.return_type.dimension == 0:
                code += '\tl.d   $f30, 0($sp)\n'
                code += '\taddi $sp, $sp, 8\n'
            elif funct.return_type.name != 'void':
                code += '\tlw   $t8, 0($sp)\n'
                code += '\taddi $sp, $sp, 8\n'
            # todo wither is it essential to pop expr from stack or not or do this in caller side?
            local_var_count_of_this_scope = self.stack_local_params_count[-1]
            for local_var in reversed(self.stack_local_params[-local_var_count_of_this_scope:]):
                local_var_name = local_var[0]
                local_var_type = local_var[1]
                code += '.text\n'
                if local_var_type.name == 'double' and local_var_type.dimension == 0:
                    code += '\tl.d  $f0, 0($sp)\n'
                    code += '\taddi $sp, $sp, 8\n'
                    code += '\ts.d  $f0, {}\n\n'.format(local_var_name.replace("/", "_"))
                else:
                    code += '\tlw   $t0, 0($sp)\n'
                    code += '\taddi $sp, $sp, 8\n'
                    code += '\tsw   $t0, {}\n\n'.format(local_var_name.replace("/", "_"))
            # self.stack_local_params = self.stack_local_params[:-local_var_count_of_this_scope]
            # self.stack_local_params_count.pop()       # sepehr
            if funct.return_type.name == 'double' and funct.return_type.dimension == 0:
                code += '\taddi $sp, $sp, -8\n'
                code += '\ts.d   $f30, 0($sp)\n'
            elif funct.return_type.name != 'void':
                code += '\taddi $sp, $sp, -8\n'
                code += '\tsw   $t8, 0($sp)\n'
            code += '\tjr   $ra\n\n'
        elif child.data == 'print_stmt':
            code += self.visit(child)
        elif child.data == 'expr' or child.data == 'ass':
            code += self.visit(child)
            # print('     ->>', child)
            expr_type = self.expr_types[-1]
            if expr_type.name != 'void':
                code += '.text\n'
                code += '\taddi\t$sp, $sp, 8\n\n'
            self.expr_types.pop()
        else:
            code += self.visit(child)
        # if child.data == 'for_stmt':
        #     for for_child in child.children:
        #         if for_child.data == 'ass' or for_child.data == 'expr':
        #             print('yes')
        #             pass

        code += 'end_stmt_{}:\n'.format(stmt_id)
        self.stmt_labels = self.stmt_labels[:store_len]
        self.stmt_labels.append(stmt_id)
        return code

    def break_stmt(self, tree):
        code = tab("""
            .text\t\t\t\t# break
                j end_stmt_{}
            ##             
        """.format(self.loop_labels[-1]))
        return code

    def return_stmt(self, tree):
        return ''.join(self.visit_children(tree))

    def if_stmt(self, tree):
        code = '# if starts here:\n'
        code += self.visit(tree.children[0])
        then_code = self.visit(tree.children[1])
        else_code = '' if len(tree.children) == 2 else self.visit(tree.children[2])
        if len(tree.children) == 2:
            code += tab(
                """
                .text\t\t\t\t#If
                    lw $a0, 0($sp)
                    addi $sp, $sp, 8
                    beq $a0, 0, end_stmt_{then}
                    j  start_stmt_{then}
                """.format(then=self.stmt_labels[-1])
            )
            code += then_code
        else:
            code += tab("""
                .text\t\t\t\t# IfElse
                    lw $a0, 0($sp)
                    addi $sp, $sp, 8
                    beq $a0, 0, start_stmt_{els}
                """.format(els=self.stmt_labels[-1]))
            code += then_code
            code += tab("j end_stmt_{els}".format(els=self.stmt_labels[-1]))
            code += else_code
        return code

    def while_stmt(self, tree):
        while_id = tree._meta
        self.loop_labels.append(while_id)
        store_len = len(self.stmt_labels)
        code = '.text\t\t\t\t# While\n'
        code += self.visit(tree.children[0])
        stmt_code = self.visit(tree.children[1])
        code += tab("""
            lw $a0, 0($sp)
            addi $sp, $sp, 8
            beq $a0, 0, end_stmt_{while_end}
        """.format(while_end=while_id))
        code += stmt_code
        code += tab("j start_stmt_{while_start}".format(while_start=while_id))
        self.stmt_labels = self.stmt_labels[:store_len]
        self.loop_labels.pop()
        return code

    def for_stmt(self, tree):
        code = '.text\t\t\t\t# For'
        for_id = tree._meta
        self.loop_labels.append(for_id)
        childs = tree.children
        next = ''
        if childs[0].data == 'ass':
            code += self.visit(childs[1])
        else:
            code += self.visit(childs[0])
        if childs[-2].data == 'ass':
            next += self.visit(childs[-2])
            next += '\taddi $sp, $sp, 8\n'
        code += tab("""
            lw $a0, 0($sp)
            addi $sp, $sp, 8
            beq $a0, $zero, end_stmt_{}
        """.format(for_id))
        code += self.visit(childs[-1])
        code += next
        code += "\tj start_stmt_{}\n".format(for_id)
        self.loop_labels.pop()
        return code

    # probably we wont need this part in cgen
    def class_decl(self, tree):
        code = ''
        ident = tree.children[0]
        self.current_scope += "/__class__" + ident.value

        class_object = class_type_objects[class_table[ident.value]]
        code += '.data\n'
        code += '.align 2\n'
        code += '{}: .space 4\n'.format(class_object.name + '_vtable')
        code += '.text\n'
        code += '__init__vtable_{}:\n'.format(self.class_cnt)
        code += '\tli $a0, {}\n'.format(len(class_object.functions) * 4)
        code += '\tli $v0, 9\n'
        code += '\tsyscall\n'
        code += '\tsw $v0, {}\n'.format(class_object.name + '_vtable')
        self.class_cnt += 1
        counter = 0
        for func in class_object.functions:
            code += '\tla $t0, {}\n'.format(func.exact_name.replace('/', '_'))
            code += '\tsw $t0, {}($v0)\n'.format(counter)
            counter += 4
        code += '\tjr $ra\n'

        if len(tree.children) > 1:
            if type(tree.children[1]) == lark.lexer.Token:
                for field in tree.children[2:]:
                    if field.children[0].data == 'function_decl':
                        code += self.visit(field)
            else:
                for field in tree.children[1:]:
                    if field.children[0].data == 'function_decl':
                        code += self.visit(field)

        self.current_scope = pop_scope(self.current_scope)
        return code

    def field(self, tree):
        code = ''
        for child in tree.children:
            if child.data == 'function_decl':
                code += self.visit(child)
                pass
        return code

    def variable_decl(self, tree):
        code = ''
        variable = tree.children[0]
        var_type = variable.children[0]
        size = 4
        if type(var_type.children[0]) == lark.lexer.Token:
            var_type = var_type.children[0].value
            if var_type == 'double':
                size = 8
            elif var_type == 'string':
                code += '.data\n'
                code += '.align 2\n'
                code += self.current_scope.replace('/', '_') + '_' + variable.children[1] + ': .space ' + str(
                    size) + '\n'
                code += '.text\n'
                code += '\tli $a0, 256\n'
                code += '\tli $v0, 9\n'
                code += '\tsyscall\n'
                code += '\tsw $v0, ' + self.current_scope.replace('/', '_') + '_' + variable.children[1] + '\n\n'
                return code
        name = variable.children[1]
        code += '.data\n'
        code += '.align 2\n'
        code += self.current_scope.replace('/', '_') + '_' + name + ': .space ' + str(size) + '\n\n'
        return code

    def type(self, tree):
        if type(tree.children[0]) == lark.lexer.Token:
            self.last_type = Type(tree.children[0])
        else:
            self.visit(tree.children[0])
            self.last_type.dimension += 1
        return ''

    def expr(self, tree):
        return ''.join(self.visit_children(tree))

    def expr8(self, tree):
        return ''.join(self.visit_children(tree))

    def expr1(self, tree):
        return ''.join(self.visit_children(tree))

    def expr2(self, tree):
        return ''.join(self.visit_children(tree))

    def expr3(self, tree):
        return ''.join(self.visit_children(tree))

    def expr4(self, tree):
        return ''.join(self.visit_children(tree))

    def expr5(self, tree):
        return ''.join(self.visit_children(tree))

    def expr6(self, tree):
        return ''.join(self.visit_children(tree))

    def expr7(self, tree):
        child_codes = self.visit_children(tree)
        if len(child_codes) == 0:
            return ''
        return ''.join(child_codes)

    def read_line(self, tree):
        code = tab("""
        .text\t\t\t\t # Read Line
            li $a0, 256         #Maximum string length
            li $v0, 9           #sbrk
            syscall
            sub $sp, $sp, 8
            sw $v0, 0($sp)
            move $a0, $v0
            li $a1, 256         #Maximum string length (incl. null)
            li $v0, 8           #read_string
            syscall             #ReadLine()
            
            lw $a0, 0($sp)      #Replace \\n to \\r(?)
            lw $t1, nw
            read_{label_id}:
                lb $t0, 0($a0)
                beq $t0, 10, e_read_{label_id}
                addi $a0, $a0, 1
                j read_{label_id}
            e_read_{label_id}:
                lb $t2, 1($a0)
                sb $t2, 0($a0)
        ##
        """.format(label_id=cnt()))
        self.expr_types.append(Type(Types.STRING))
        return code

    def read_integer(self, tree):
        code = tab("""
            .text\t\t\t\t # Read Integer
                li $v0, 5           #read_integer
                syscall             #ReadInteger()
                sub $sp, $sp, 8
                sw $v0, 0($sp)
            ##
            """)
        self.expr_types.append(Type(Types.INT))
        return code

    def new_array(self, tree):
        code = ''
        code += ''.join(self.visit_children(tree))
        shamt = 2
        tp = tree.children[1].children[0]
        if type(tp) == lark.lexer.Token:
            if tp.value == Types.DOUBLE:
                shamt = 3
        """
        we store size of array in 8 bytes before start pointer of array
        """
        code += tab("""
            .text\t\t\t\t # New array
                lw $a0, 0($sp)
                addi $sp, $sp, 8
                addi $t6, $a0, 0 # t6 is length of array
                sll $a0, $a0, {shamt}
                addi $a0, $a0, 8 # extra 8 bytes for length
                li $v0, 9           #rsbrk
                syscall
                sw $t6 0($v0)
                addi $v0, $v0, 8
                sub $sp, $sp, 8
                sw $v0, 0($sp)\n
            ##
        """.format(shamt=shamt))
        self.expr_types.append(Type(name=self.last_type.name, dimension=self.last_type.dimension + 1))
        return code

    def get_type(self, typ):
        if type(typ) == lark.lexer.Token:
            return Type(typ)
        ret = self.get_type(typ.children[0])
        ret.dimension += 1
        return ret

    def not_expr(self, tree):
        code = ''.join(self.visit_children(tree))
        code += tab("""
            .text\t\t\t\t # Not
                lw $t0, 0($sp)
                addi $sp, $sp, 8
                li $t1, 1
                beq $t0, 0, not_{0}
                    li $t1, 0
                not_{0}:
                    sub  $sp, $sp, 8
                    sw $t1, 0($sp)
            ##
        """.format(cnt()))
        self.expr_types.pop()
        self.expr_types.append(Type(Types.BOOL))
        return code

    def neg(self, tree):
        code = ''.join(self.visit_children(tree))
        typ = self.expr_types[-1]
        if typ.name == 'int':
            code += tab("""
                .text\t\t\t\t# Neg int
                    lw $t0, 0($sp)
                    sub $t0, $zero, $t0
                    sw $t0, 0($sp)
                ##
                """)
        else:
            code += tab("""
                .text\t\t\t\t# Neg double
                    l.d $f0, 0($sp)
                    neg.d $f0, $f0
                    s.d $f0, 0($sp)
                ##
            """)
        return code

    def print(self, tree):
        code = ''
        for child in tree.children[0].children:
            code += self.visit(child)
            t = self.expr_types[-1]
            self.expr_types.pop()
            code += '.text\n'
            if t.name == 'double':
                code += tab("""
                    .text
                        l.d $f6, 0($sp)
                        addi $sp, $sp, 8 
                
                	.text
                        l.d  $f0, root_print_double___x
                        addi $sp, $sp, -8
                        s.d  $f0, 0($sp)
                    
                    .text
                        sub $sp, $sp, 8
                        s.d $f6, 0($sp)
                    
                    .text
                        l.d  $f0, 0($sp)
                        s.d  $f0, root_print_double___x
                        addi $sp, $sp, 8
                    
                    .text
                        addi $sp, $sp, -8
                        sw   $ra, 0($sp)
                        jal root_print_double__
                        lw   $ra, 0($sp)
                        addi $sp, $sp, 8
                    
                        l.d  $f0, 0($sp)
                        addi $sp, $sp, 8
                        s.d  $f0, root_print_double___x
                """)
                # code += tab("""
                #     l.d $f12, 0($sp)
                #     addi $sp, $sp, 8
                #     li $v0, 3
                #     syscall
                # """)
            #                 print("""
            # l.d $f12, 0($sp)
            # addi $sp, $sp, 8
            # li $v0, 3
            # syscall
            #                 """)
            elif t.name == 'int':
                code += tab("""
                    # Print int
                        li $v0, 1
                        lw $a0, 0($sp)
                        addi $sp, $sp, 8
                        syscall             #Print int
                    ##
                """)
            elif t.name == Types.STRING:
                code += tab(
                    """
                    # Print string
                        li $v0, 4
                        lw $a0, 0($sp)
                        addi $sp, $sp, 8
                        syscall             #Print string
                    ##
                    """)
            elif t.name == 'bool' and t.dimension == 0:
                code += tab(
                    """
                    # Print bool
                        lw $a0, 0($sp)
                        addi $sp, $sp, 8
                        beq $a0, 0, zero_{cnt}
                        li $v0, 4
                        la $a0, true
                        syscall
                        j ezero_{cnt}
                        zero_{cnt}:
                        li $v0, 4
                        la $a0, false
                        syscall             #Print bool
                        ezero_{cnt}:
                    ##
                    """.format(cnt=cnt())
                )
        # '\n' at the end of print
        code += tab(
            """
            # Print new line
                li $v0, 4
                la $a0, nw
                syscall\t\t\t\t#Print new line\n
            ##
            """)
        return code

    def const_int(self, tree):
        code = ''
        code += '.text\n'
        code += '\tli $t0, {}\n'.format(tree.children[0].value.lower())
        code += '\tsub $sp, $sp, 8\n'
        code += '\tsw $t0, 0($sp)\n\n'
        self.expr_types.append(Type('int'))
        return code

    def const_double(self, tree):
        code = ''
        dval = tree.children[0].value.lower()
        if dval[-1] == '.':
            dval += '0'
        if '.e' in dval:
            index = dval.find('.e') + 1
            dval = dval[:index] + '0' + dval[index:]
        code += '.text\n'
        code += '\tli.d $f0, {}\n'.format(dval)
        code += '\tsub $sp, $sp, 8\n'
        code += '\ts.d $f0, 0($sp)\n\n'
        self.expr_types.append(Type('double'))
        return code

    def const_bool(self, tree):
        code = ''
        code += '.text\n'
        code += '\tli $t0, {}\n'.format(int(tree.children[0].value == 'true'))
        code += '\tsub $sp, $sp, 8\n'
        code += '\tsw $t0, 0($sp)\n'
        self.expr_types.append(Type('bool'))
        return code

    def const_str(self, tree):
        code = ''
        code += '.data\n'
        code += '.align 2\n'
        code += '__const_str__{}: .asciiz {}\n'.format(self.str_const, tree.children[0].value)
        code += '.text\n'
        code += '\tla $t0, __const_str__{}\n'.format(self.str_const)
        code += '\tsub $sp, $sp, 8\n'
        code += '\tsw $t0, 0($sp)\n\n'
        self.str_const += 1
        self.expr_types.append(Type('string'))
        return code

    def add(self, tree):
        code = ''.join(self.visit_children(tree))
        typ = self.expr_types.pop()
        if typ.name == 'int':
            code += '.text\n'
            code += '\tlw $t0, 0($sp)\n'
            code += '\tlw $t1, 8($sp)\n'
            code += '\tadd $t2, $t1, $t0\n'
            code += '\tsw $t2, 8($sp)\n'
            code += '\taddi $sp, $sp, 8\n\n'
        else:
            code += '.text\n'
            code += '\tl.d $f0, 0($sp)\n'
            code += '\tl.d $f2, 8($sp)\n'
            code += '\tadd.d $f4, $f2, $f0\n'
            code += '\ts.d $f4, 8($sp)\n'
            code += '\taddi $sp, $sp, 8\n\n'
        return code

    def call(self, tree):
        # self.expr_types
        if len(tree.children) == 3:
            code = self.visit(tree.children[0])
            if self.expr_types[-1].dimension > 0:
                code += '.text\n'
                code += '\tlw $t0, 0($sp)\n'
                code += '\tlw $t0, -8($t0)\n'
                code += '\tsw $t0, 0($sp)\n\n'
                self.expr_types.pop()
                self.expr_types.append(Type(Types.INT))
                return code
            else:
                self.expr_types.pop()
                expr_class_inst = tree.children[0]
                ident = tree.children[1]
                actuals = tree.children[2]
                name = ident.value

                actuals._meta = [name, expr_class_inst]
                return self.visit(actuals)

            # for class
            pass
        if len(tree.children) == 2:
            # self.stack_local_params_count.append(0)
            ident = tree.children[0]
            actuals = tree.children[1]
            name = ident.value

            actuals._meta = [name, None]
            return self.visit(actuals)

    def actuals(self, tree):
        code = '.text\n'
        function_name = tree._meta[0]
        if tree._meta[1]:
            expr = tree._meta[1]
            tmp = self.visit(expr)
            class_type = self.expr_types[-1]
            self.expr_types.pop()
            function_scope = 'root/__class__' + class_type.name + '/' + function_name
            function = class_type_objects[class_table[class_type.name]].find_function(name=function_name)
        else:
            function_scope = 'root/' + function_name
            function = function_objects[function_table[function_name]]

        # push formal parameter
        for formal in function.formals:
            exact_name = function_scope
            if tree._meta[1]:
                tmp = self.visit(tree._meta[1])
                class_type = self.expr_types[-1]
                self.expr_types.pop()
                for funct in class_type_objects[class_table[class_type.name]].functions:
                    if funct.name == function_name:
                        exact_name = funct.exact_name
            formal_name = (exact_name + "/" + formal[0]).replace("/", "_")
            formal_type = formal[1]
            if formal_type.name == 'double' and formal_type.dimension == 0:
                code += '\tl.d  $f0, {}\n'.format(formal_name)
                code += '\taddi $sp, $sp, -8\n'
                code += '\ts.d  $f0, 0($sp)\n\n'
            else:
                code += '\tlw   $t1, {}\n'.format(formal_name)
                code += '\taddi $sp, $sp, -8\n'
                code += '\tsw   $t1, 0($sp)\n\n'

        # set actual parameters to formal parameters
        if tree._meta[1]:
            exact_name = function_scope
            if tree._meta[1]:
                tmp = self.visit(tree._meta[1])
                class_type = self.expr_types[-1]
                self.expr_types.pop()
                for funct in class_type_objects[class_table[class_type.name]].functions:
                    if funct.name == function_name:
                        exact_name = funct.exact_name
            formal_name = (exact_name + "/" + function.formals[0][0]).replace("/", "_")
            # set 'this'
            # todo is it really a pointer or it's just a name?
            expr = tree._meta[1]
            code += self.visit(expr)
            # formal_name = function.formals[0][0]
            code += '.text\n'
            code += '\tlw $v0, 0($sp)\n'  # we don't use type because we are sure that it's class
            # code += '\tsw $v0, {}\n'.format((function_scope + "/" + formal_name).replace("/", "_"))
            code += '\tsw $v0, {}\n'.format(formal_name)
            code += '\taddi $sp, $sp, 8\n'
            self.expr_types.pop()
            actual_counter = 1
        else:
            actual_counter = 0

        for expr in tree.children:
            code += self.visit(expr)
            formal_name = function.formals[actual_counter][0]
            code += '.text\n'
            formal_type = function.formals[actual_counter][1]
            if formal_type.name == 'double' and formal_type.dimension == 0:
                code += '\tl.d  $f0, 0($sp)\n'
                code += '\ts.d  $f0, {}\n'.format((function_scope + "/" + formal_name).replace("/", "_"))
                code += '\taddi $sp, $sp, 8\n\n'
            else:
                code += '\tlw   $v0, 0($sp)\n'
                code += '\tsw   $v0, {}\n'.format((function_scope + "/" + formal_name).replace("/", "_"))
                code += '\taddi $sp, $sp, 8\n\n'
            actual_counter += 1
            self.expr_types.pop() # todo check f(double, double) + g(double, double) f: int g: int

        code += '.text\n'
        code += '\taddi $sp, $sp, -8\n'
        code += '\tsw   $ra, 0($sp)\n'

        if tree._meta[1]: # E1.ident(E1, expr, expr, ...)
            expr = tree._meta[1]
            code += self.visit(expr)
            class_type = self.expr_types[-1]
            self.expr_types.pop()
            index = class_type_objects[class_table[class_type.name]].find_function_index(function_name)
            code += '.text\n'
            code += '\tlw $t0, 0($sp)\n'
            code += '\taddi $sp, $sp, 8\n'
            code += '\tlw $t0, 0($t0)\n'
            code += '\taddi $t0, $t0, {}\n'.format(4 * index)
            code += '\tlw $t0, 0($t0)\n'
            code += '\tjalr $t0\n'
        else:
            label_name = function.exact_name
            code += '\tjal {}\n'.format(label_name.replace('/', '_'))

        if function.return_type.name == 'double' and function.return_type.dimension == 0:
            code += '\tl.d   $f30, 0($sp)\n'
            code += '\taddi $sp, $sp, 8\n'
        elif function.return_type.name != 'void':
            code += '\tlw   $t8, 0($sp)\n'
            code += '\taddi $sp, $sp, 8\n'

        code += '\tlw   $ra, 0($sp)\n'
        code += '\taddi $sp, $sp, 8\n\n'

        # pop formal parameters
        for formal in reversed(function.formals):
            exact_name = function_scope
            if tree._meta[1]:
                tmp = self.visit(tree._meta[1])
                class_type = self.expr_types[-1]
                self.expr_types.pop()
                for funct in class_type_objects[class_table[class_type.name]].functions:
                    if funct.name == function_name:
                        exact_name = funct.exact_name
            formal_name = (exact_name + "/" + formal[0]).replace("/", "_")
            formal_type = formal[1]
            if formal_type.name == 'double' and formal_type.dimension == 0:
                code += '\tl.d  $f0, 0($sp)\n'
                code += '\taddi $sp, $sp, 8\n'
                code += '\ts.d  $f0, {}\n\n'.format(formal_name)
            else:
                code += '\tlw   $t0, 0($sp)\n'
                code += '\taddi $sp, $sp, 8\n'
                code += '\tsw   $t0, {}\n\n'.format(formal_name)
        if function.return_type.name == 'double' and function.return_type.dimension == 0:
            code += '\taddi $sp, $sp, -8\n'
            code += '\ts.d   $f30, 0($sp)\n'
        elif function.return_type.name != 'void':
            code += '\taddi $sp, $sp, -8\n'
            code += '\tsw   $t8, 0($sp)\n'
        code += '# return type is ' + function.return_type.name + ' ' + str(function.return_type.dimension)
        code += '\n'
        self.expr_types.append(deepcopy(function.return_type))
        return code

    def sub(self, tree):
        code = ''.join(self.visit_children(tree))
        typ = self.expr_types.pop()
        if typ.name == 'int':
            code += '.text\n'
            code += '\tlw $t0, 0($sp)\n'
            code += '\tlw $t1, 8($sp)\n'
            code += '\tsub $t2, $t1, $t0\n'
            code += '\tsw $t2, 8($sp)\n'
            code += '\taddi $sp, $sp, 8\n\n'
        else:
            code += '.text\n'
            code += '\tl.d $f0, 0($sp)\n'
            code += '\tl.d $f2, 8($sp)\n'
            code += '\tsub.d $f4, $f2, $f0\n'
            code += '\ts.d $f4, 8($sp)\n'
            code += '\taddi $sp, $sp, 8\n\n'
        return code

    def mul(self, tree):
        code = ''.join(self.visit_children(tree))
        typ = self.expr_types.pop()
        if typ.name == 'int':
            code += '.text\n'
            code += '\tlw   $t0, 0($sp)\n'
            code += '\tlw   $t1, 8($sp)\n'
            code += '\tmul  $t2, $t1, $t0\n'
            code += '\tsw   $t2, 8($sp)\n'
            code += '\taddi $sp, $sp, 8\n\n'
        if typ.name == 'double':
            code += '.text\n'
            code += '\tl.d      $f0, 0($sp)\n'
            code += '\tl.d      $f2, 8($sp)\n'
            code += '\tmul.d    $f4, $f2, $f0\n'
            code += '\ts.d      $f4, 8($sp)\n'
            code += '\taddi     $sp, $sp, 8\n\n'
        return code

    def div(self, tree):
        code = ''.join(self.visit_children(tree))
        typ = self.expr_types.pop()
        if typ.name == 'int':
            code += '.text\n'
            code += '\tlw $t0, 0($sp)\n'
            code += '\tlw $t1, 8($sp)\n'
            code += '\tdiv $t2, $t1, $t0\n'
            code += '\tsw $t2, 8($sp)\n'
            code += '\taddi $sp, $sp, 8\n\n'
        if typ.name == 'double':
            code += '.text\n'
            code += '\tl.d $f0, 0($sp)\n'
            code += '\tl.d $f2, 8($sp)\n'
            code += '\tdiv.d $f4, $f2, $f0\n'
            code += '\ts.d $f4, 8($sp)\n'
            code += '\taddi $sp, $sp, 8\n\n'
        return code

    def mod(self, tree):
        code = ''.join(self.visit_children(tree))
        code += '.text\n'
        code += '\tlw $t0, 0($sp)\n'
        code += '\tlw $t1, 8($sp)\n'
        code += '\tdiv $t1, $t0\n'
        code += '\tmfhi $t2\n'
        code += '\tsw $t2, 8($sp)\n'
        code += '\taddi $sp, $sp, 8\n'
        self.expr_types.pop()
        return code

    def le(self, tree):
        code = ''.join(self.visit_children(tree))
        typ = self.expr_types.pop()
        if typ.name == 'int':
            code += '.text\n'
            code += '\tlw $t0, 0($sp)\n'
            code += '\tlw $t1, 8($sp)\n'
            code += '\tsle $t2, $t1, $t0\n'
            code += '\tsw $t2, 8($sp)\n'
            code += '\taddi $sp, $sp, 8\n\n'
        if typ.name == 'double':
            label_cnt = cnt()
            code += '.text\n'
            code += '\tli $t0, 0\n'
            code += '\tl.d $f0, 0($sp)\n'
            code += '\tl.d $f2, 8($sp)\n'
            code += '\tc.le.d $f2, $f0\n'
            code += '\tbc1f __double_le__{}\n'.format(label_cnt)
            code += '\tli $t0, 1\n'
            code += '__double_le__{}:\tsw $t0, 8($sp)\n'.format(label_cnt)
            code += '\taddi $sp, $sp, 8\n\n'
        self.expr_types.pop()
        self.expr_types.append(Type('bool'))
        return code

    def lt(self, tree):
        code = ''.join(self.visit_children(tree))
        typ = self.expr_types.pop()
        if typ.name == 'int':
            code += '.text\n'
            code += '\tlw $t0, 0($sp)\n'
            code += '\tlw $t1, 8($sp)\n'
            code += '\tslt $t2, $t1, $t0\n'
            code += '\tsw $t2, 8($sp)\n'
            code += '\taddi $sp, $sp, 8\n\n'
        if typ.name == 'double':
            label_cnt = cnt()
            code += '.text\n'
            code += '\tli $t0, 0\n'
            code += '\tl.d $f0, 0($sp)\n'
            code += '\tl.d $f2, 8($sp)\n'
            code += '\tc.lt.d $f2, $f0\n'
            code += '\tbc1f __double_lt__{}\n'.format(label_cnt)
            code += '\tli $t0, 1\n'
            code += '__double_lt__{}:\tsw $t0, 8($sp)\n'.format(label_cnt)
            code += '\taddi $sp, $sp, 8\n\n'
        self.expr_types.pop()
        self.expr_types.append(Type('bool'))
        return code

    def ge(self, tree):
        code = ''.join(self.visit_children(tree))
        typ = self.expr_types.pop()
        if typ.name == 'int':
            code += '.text\n'
            code += '\tlw $t0, 0($sp)\n'
            code += '\tlw $t1, 8($sp)\n'
            code += '\tsge $t2, $t1, $t0\n'
            code += '\tsw $t2, 8($sp)\n'
            code += '\taddi $sp, $sp, 8\n\n'
        if typ.name == 'double':
            label_cnt = cnt()
            code += '.text\n'
            code += '\tli $t0, 0\n'
            code += '\tl.d $f0, 0($sp)\n'
            code += '\tl.d $f2, 8($sp)\n'
            code += '\tc.lt.d $f2, $f0\n'
            code += '\tbc1t __double_lt__{}\n'.format(label_cnt)
            code += '\tli $t0, 1\n'
            code += '__double_lt__{}:\tsw $t0, 8($sp)\n'.format(label_cnt)
            code += '\taddi $sp, $sp, 8\n\n'
        self.expr_types.pop()
        self.expr_types.append(Type('bool'))
        return code

    def gt(self, tree):
        code = ''.join(self.visit_children(tree))
        typ = self.expr_types.pop()
        if typ.name == 'int':
            code += '.text\n'
            code += '\tlw $t0, 0($sp)\n'
            code += '\tlw $t1, 8($sp)\n'
            code += '\tsgt $t2, $t1, $t0\n'
            code += '\tsw $t2, 8($sp)\n'
            code += '\taddi $sp, $sp, 8\n\n'
        if typ.name == 'double':
            label_cnt = cnt()
            code += '.text\n'
            code += '\tli $t0, 0\n'
            code += '\tl.d $f0, 0($sp)\n'
            code += '\tl.d $f2, 8($sp)\n'
            code += '\tc.le.d $f2, $f0\n'
            code += '\tbc1t __double_gt__{}\n'.format(label_cnt)
            code += '\tli $t0, 1\n'
            code += '__double_gt__{}:\tsw $t0, 8($sp)\n'.format(label_cnt)
            code += '\taddi $sp, $sp, 8\n\n'
        self.expr_types.pop()
        self.expr_types.append(Type('bool'))
        return code

    def eq(self, tree):
        code = ''.join(self.visit_children(tree))
        typ = self.expr_types.pop()
        if typ.name == 'double' and typ.dimension == 0:
            label_cnt = cnt()
            code += '.text\n'
            code += '\tli $t0, 0\n'
            code += '\tl.d $f0, 0($sp)\n'
            code += '\tl.d $f2, 8($sp)\n'
            code += '\tc.eq.d $f0, $f2\n'
            code += '\tbc1f __double_eq__{}\n'.format(label_cnt)
            code += '\tli $t0, 1\n'
            code += '__double_eq__{}:\tsw $t0, 8($sp)\n'.format(label_cnt)
            code += '\taddi $sp, $sp, 8\n\n'
        elif typ.name == 'string' and typ.dimension == 0:
            code += '.text\n'
            code += '\tsw $t0, -8($sp)\n'
            code += '\tsw $t1, -8($sp)\n'
            code += '\tsw $a0, -12($sp)\n'
            code += '\tsw $a1, -16($sp)\n'
            code += '\tsw $v0, -20($sp)\n'
            code += '\tsw $ra, -24($sp)\n'
            code += '\tlw $a0, 0($sp)\n'
            code += '\tlw $a1, 8($sp)\n'
            code += '\tjal __strcmp__\n'
            code += '\tsw $v0, 8($sp)\n'
            code += '\tlw $t0, -4($sp)\n'
            code += '\tlw $t1, -8($sp)\n'
            code += '\tlw $a0, -12($sp)\n'
            code += '\tlw $a1, -16($sp)\n'
            code += '\tlw $v0, -20($sp)\n'
            code += '\tlw $ra, -24($sp)\n'
            code += '\taddi $sp, $sp, 8\n\n'
        elif self:
            code += '.text\n'
            code += '\tlw $t0, 0($sp)\n'
            code += '\tlw $t1, 8($sp)\n'
            code += '\tseq $t2, $t1, $t0\n'
            code += '\tsw $t2, 8($sp)\n'
            code += '\taddi $sp, $sp, 8\n\n'
        self.expr_types.pop()
        self.expr_types.append(Type('bool'))
        return code

    def ne(self, tree):
        code = ''.join(self.visit_children(tree))
        typ = self.expr_types.pop()
        if typ.name == 'double' and typ.dimension == 0:
            label_cnt = cnt()
            code += '.text\n'
            code += '\tli $t0, 0\n'
            code += '\tl.d $f0, 0($sp)\n'
            code += '\tl.d $f2, 8($sp)\n'
            code += '\tc.eq.d $f0, $f2\n'
            code += '\tbc1t __double_ne__{}\n'.format(label_cnt)
            code += '\tli $t0, 1\n'
            code += '__double_ne__{}:\tsw $t0, 8($sp)\n'.format(label_cnt)
            code += '\taddi $sp, $sp, 8\n\n'
        elif typ.name == 'string' and typ.dimension == 0:
            code += '.text\n'
            code += '\tsw $t0, -8($sp)\n'
            code += '\tsw $t1, -8($sp)\n'
            code += '\tsw $a0, -12($sp)\n'
            code += '\tsw $a1, -16($sp)\n'
            code += '\tsw $v0, -20($sp)\n'
            code += '\tsw $ra, -24($sp)\n'
            code += '\tlw $a0, 0($sp)\n'
            code += '\tlw $a1, 8($sp)\n'
            code += '\tjal __strcmp__\n'
            code += '\tli $t0, 1\n'
            code += '\tsub $v0, $t0, $v0\n'
            code += '\tsw $v0, 8($sp)\n'
            code += '\tlw $t0, -4($sp)\n'
            code += '\tlw $t1, -8($sp)\n'
            code += '\tlw $a0, -12($sp)\n'
            code += '\tlw $a1, -16($sp)\n'
            code += '\tlw $v0, -20($sp)\n'
            code += '\tlw $ra, -24($sp)\n'
            code += '\taddi $sp, $sp, 8\n\n'
        elif self:
            code += '.text\n'
            code += '\tlw $t0, 0($sp)\n'
            code += '\tlw $t1, 8($sp)\n'
            code += '\tsne $t2, $t1, $t0\n'
            code += '\tsw $t2, 8($sp)\n'
            code += '\taddi $sp, $sp, 8\n\n'
        self.expr_types.pop()
        self.expr_types.append(Type('bool'))
        return code

    def and_bool(self, tree):
        code = ''.join(self.visit_children(tree))
        code += '.text\n'
        code += '\tlw $t0, 0($sp)\n'
        code += '\tlw $t1, 8($sp)\n'
        code += '\tand $t2, $t1, $t0\n'
        code += '\tsw $t2, 8($sp)\n'
        code += '\taddi $sp, $sp, 8\n\n'
        self.expr_types.pop()
        self.expr_types.pop()
        self.expr_types.append(Type('bool'))
        return code

    def or_bool(self, tree):
        code = ''.join(self.visit_children(tree))
        code += '.text\n'
        code += '\tlw $t0, 0($sp)\n'
        code += '\tlw $t1, 8($sp)\n'
        code += '\tor $t2, $t1, $t0\n'
        code += '\tsw $t2, 8($sp)\n'
        code += '\taddi $sp, $sp, 8\n\n'
        self.expr_types.pop()
        self.expr_types.pop()
        self.expr_types.append(Type(Types.BOOL))
        return code

    def null(self, tree):
        code = '.text\n'
        code += '\tsub $sp, $sp, 4\n'
        code += '\tsw $zero, 0($sp)\n\n'
        self.expr_types.append(Type('null'))
        return code

    def l_value(self, tree):
        return ''.join(self.visit_children(tree))

    def var_addr(self, tree):
        var_scope = self.current_scope
        var_name = tree.children[0].value
        while (var_scope, var_name) not in symbol_table:
            var_scope = pop_scope(var_scope)
                # inja :D chon ta'rif nashode, while tamum nemishe; dombale moteghayyere dorost migardam dg. be scope asli kar nadaram. mannnnnnn kari lazem nist bokonim. code ghalat nemidan ke. Re Dg:)) tarif nakardam y ro
        if '__class__' in var_scope.split('/')[-1]:
            class_name = var_scope.split('/')[-1][9:]
            class_obj = class_type_objects[class_table[class_name]]
            index = class_obj.find_var_index(var_name)
            if index >= 0:
                function_name = deepcopy(self.current_scope).split('/')
                while function_name[-1] != '_local':
                    function_name.pop()
                function_name.pop()
                this_label = '/'.join(function_name).replace('/', '_') + '_this'
                code = '.text\n'
                code += '\tlw $t0, {}\n'.format(this_label)
                code += '\taddi $t1, $t0, {}\n'.format((1 + index) * 8)
                code += '\tsub $sp, $sp, 8\n'
                code += '\tsw $t1, 0($sp)\n'
                self.expr_types.append(deepcopy(class_obj.find_var_type(var_name)))
                return code
        label_name = var_scope.replace('/', '_') + '_' + var_name
        code = '.text\n'
        code += '\tla $t0, {}\n'.format(label_name)
        code += '\tsub $sp, $sp, 8\n'
        code += '\tsw $t0, 0($sp)\n\n'
        typ = symbol_table_objects[symbol_table[var_scope, var_name]].type
        self.expr_types.append(deepcopy(typ))
        return code

    def subscript(self, tree):
        code = ''.join(self.visit_children(tree))
        self.expr_types.pop()
        typ = self.expr_types[-1]
        if typ.name == Types.DOUBLE and typ.dimension == 1:
            code += '.text\n'
            code += '\tlw $t7, 8($sp)\n'
            code += '\tlw $t0, 0($sp)\n'
            # code += '\taddi $t0, $t0, 8\n'
            code += '\tli $t1, 8\n'
            code += '\tmul $t0, $t0, $t1\n'
            code += '\tadd $t1, $t0, $t7\n'
            code += '\tsw $t1, 8($sp)\n'
            code += '\taddi $sp, $sp, 8\n\n'
        else:
            code += '.text\n'
            code += '\tlw $t7, 8($sp)\n'
            code += '\tlw $t0, 0($sp)\n'
            # code += '\taddi $t0, $t0, 8\n'
            code += '\tli $t1, 4\n'
            code += '\tmul $t0, $t0, $t1\n'
            code += '\tadd $t1, $t0, $t7\n'
            code += '\tsw $t1, 8($sp)\n'
            code += '\taddi $sp, $sp, 8\n\n'
        self.expr_types[-1].dimension -= 1
        return code

    def val(self, tree):
        code = ''.join(self.visit_children(tree))
        typ = self.expr_types[-1]
        if typ.name == 'double' and typ.dimension == 0:
            code += '.text\n'
            code += '\tlw $t0, 0($sp)\n'
            code += '\tl.d $f0, 0($t0)\n'
            code += '\ts.d $f0, 0($sp)\n\n'
        else:
            code += '.text\n'
            code += '\tlw $t0, 0($sp)\n'
            code += '\tlw $t0, 0($t0)\n'
            code += '\tsw $t0, 0($sp)\n\n'
        return code

    def ass(self, tree):
        # print(tree)
        # input()
        code = ''.join(self.visit_children(tree))
        typ = self.expr_types[-1]
        if typ.name == 'double' and typ.dimension == 0:
            code += '.text\n'
            code += '\tlw $t0, 8($sp)\n'
            code += '\tl.d $f0, 0($sp)\n'
            code += '\ts.d $f0, 0($t0)\n'
            code += '\ts.d $f0, 8($sp)\n'
            code += '\taddi $sp, $sp, 8\n\n'
        else:
            code += '.text\n'
            code += '\tlw $t0, 8($sp)\n'
            code += '\tlw $t1, 0($sp)\n'
            code += '\tsw $t1, 0($t0)\n'
            code += '\tsw $t1, 8($sp)\n'
            code += '\taddi $sp, $sp, 8\n\n'
        self.expr_types.pop()
        return code

    def var_access(self, tree):
        ident = tree.children[1].value
        code = ''
        code += self.visit(tree.children[0])
        code += '.text\n'
        code += '\tlw $t0, 0($sp)\n'

        class_type = self.expr_types[-1]
        # if class_type.dimension > 0:
        #
        #     code += '\tlw $a0, -8($t0)\n'
        #     # code += """
        #     #             addi $a0, $sp, 0
        #     #             li $v0, 1
        #     #             syscall
        #     #             """
        #     code += '\tsw $a0, 0($sp)\n'
        #     self.expr_types.pop()
        #     self.expr_types.append(Type('int)'))
        #     return code

        var_index = class_type_objects[class_table[class_type.name]].find_var_index(ident)
        var_type = class_type_objects[class_table[class_type.name]].find_var_type(ident)

        code += '\taddi $t1, $t0, {}\n'.format((1 + var_index) * 8)
        code += '\tsw $t1, 0($sp)\n'

        self.expr_types.pop()
        self.expr_types.append(var_type)
        return code


def cgen(decaf):
    decaf = tab("""
        
    """) + decaf
    # decaf = decaf.replace('.length()', '[-2]')
    parser = Lark(grammar, parser="lalr")
    parse_tree = parser.parse(decaf)
    SymbolTableMaker().visit(parse_tree)
    # print(symbol_table)
    return CodeGenerator().visit(parse_tree)


decaf = r"""
int g() {
    return 0;
}

void f() {
    Print("Dammit");
}

class X extends Person {
    void f() {
        Print("is this right?");
    }
}

class Y extends Person {
    void call_f() {
        // f();
        this.f();
        Print("Aw?");
    }
}

class Person {
    string name;
    int age;
    
    void f() {
        Print("f!");
    }

    void setName(string new_name) {
        name = new_name;
        this.f();
        f();
    }

    void setAge(int new_age) {
        age = new_age;
    }

    void print() {
        Print("Name: ", name, " Age: ", age);
    }

}

int main() {
    Person p;
    Y y;

    string name;
    int age;

    name = ReadLine();
    age = ReadInteger();

    p = new Y;
    p.setName(name);
    p.setAge(age);

    p.print();
    y = new Y;
    y.call_f();
}
"""

if __name__ == '__main__':
    # decaf = ""
    #
    # while Tree:
    #     try:
    #         decaf += input()
    #     except:
    #         break
    # print(cg)
    # print(cgen("""
    #
    #
    #     int main(){
    #         Print(123.92);
    #     }
    #
    # """))
    # exit(0)
    # (print(cgen("""
    # class Person{
    #
    # }
    #
    # int main(){
    #     f();
    #     Print(1);
    #     f();
    #     Print(2);
    #
    # }
    #
    #
    #
    # """)))
    # exit(0)
    # print(cgen("""
    #
    # int main() {
    #     int t;
    #     int i;
    #     string s;
    #     bool found;
    #     t = 0;
    #     s = ReadLine();
    #     found = false;
    # 	for (i = 1; i < 10; i = i+1){
    # 		if (s[i] == s[i-1]){
    # 		    t = t+1;
    # 		}
    # 		else{
    # 		    t = 0;
    # 		}
    # 		if (t == 6){
    # 		    Print("YES");
    # 		    found = true;
    # 		    break;
    # 		}
    # 	}
    # 	if(!found){
    #         Print("NO");
    #     }
    # }
    #     """))
    #
    #     exit(0)
    #     (cgen("""
    #         int main(){
    #
    #         NewArray(5, double[][]);
    #         NewArray(5, int);
    #         NewArray(5, bool[]);
    #         for(i=0; i<10; i=i+1){
    #         }
    #     }
    # """))
    # exit(0)
    # print(cgen("""
    # int main(){
    #     while(true){
    #         if(ReadInteger() == 2){
    #             Print(2);
    #             break;
    #         }
    #         Print(1);
    #     }
    #     while(true){
    #         while(true){
    #             if(ReadInteger() == 2){
    #                 Print(4);
    #                 break;
    #             }
    #             Print(3);
    #         }
    #         while(true){
    #             if (false){
    #             }else{
    #                 break;
    #             }
    #             Print("holy");
    #         }
    #         break;
    #     }
    #     Print("goody goody");
    # }
    # """))
    # print(cgen(decaf))
    # exit(0)

    # (print(cgen("""
    # int main()  {
    #     int [] x;
    #     double[] d;
    #     x = NewArray(5, int);
    #     d = NewArray(3, double);
    #     d[0] = 1.1;
    #     d[1] = 2.3;
    #     d[2] = 5.6;
    #     Print(d[0], d[1], d[2]);
    # }
    #     """)))
    #     exit(0)
    #     print(cgen("""
    #
    #     int main() {
    #         int t;
    #         int i;
    #         string s;
    #         bool found;
    #         t = 0;
    #         s = ReadLine();
    #         found = false;
    #     	for (i = 1; i < 10; i = i+1){
    #     		if (s[i] == s[i-1]){
    #     		    t = t+1;
    #     		}
    #     		else{
    #     		    t = 0;
    #     		}
    #     		if (t == 6){
    #     		    Print("YES");
    #     		    found = true;
    #     		    break;
    #     		}
    #     	}
    #     	if(!found){
    #             Print("NO");
    #         }
    #     }
    #         """))
    #
    #         exit(0)
    #         (cgen("""
    #             int main(){
    #
    #             NewArray(5, double[][]);
    #             NewArray(5, int);
    #             NewArray(5, bool[]);
    #             for(i=0; i<10; i=i+1){
    #             }
    #         }
    #     """))
    #     exit(0)
    #     print(cgen("""
    #     int main(){
    #         while(true){
    #             if(ReadInteger() == 2){
    #                 Print(2);
    #                 break;
    #             }
    #             Print(1);
    #         }
    #         while(true){
    #             while(true){
    #                 if(ReadInteger() == 2){
    #                     Print(4);
    #                     break;
    #                 }
    #                 Print(3);
    #             }
    #             while(true){
    #                 if (false){
    #                 }else{
    #                     break;
    #                 }
    #                 Print("holy");
    #             }
    #             break;
    #         }
    #         Print("goody goody");
    #     }
    #     """))
    #     print(cgen(decaf))
    #     exit(0)
    #
    parser = Lark(grammar, parser="lalr")
    parse_tree = parser.parse(text=decaf)
    SymbolTableMaker().visit(parse_tree)
    ClassTreeSetter().visit(parse_tree)
    set_inheritance()
    ImplicitThis().visit(parse_tree)
    print(CodeGenerator().visit(parse_tree))
    pass

"""
power(i){
    int x ;
    x = -5;
    x = i;
    if (i > 0) {
        int i;
        power(i-1)
    }
    if i == 0:
        :return
    print(x)
    :return
}

power(3) //jal

power/i = 2
power/local/x = 2
power/local/1/i

stack_mips[?,ra,?|,3,ra,3]
stack_local_params =[x,x,x,i] //when enter a statement push per each declaration
                                //
stack_local_params_cnt =[1,1,2,0] //when new call push 
                                //when new statement +1
console:
1
2
"""

"""
Tree(function_decl, [Token(IDENT, 'sort'), Tree(formals, [Tree(variable, [Tree(type, [Tree(type, [Token(TYPE, 'int')])]), Token(IDENT, 'items')])]), Tree(stmt_block, [Tree(variable_decl, [Tree(variable, [Tree(type, [Token(TYPE, 'int')]), Token(IDENT, 'i')])]), Tree(variable_decl, [Tree(variable, [Tree(type, [Token(TYPE, 'int')]), Token(IDENT, 'j')])]), Tree(variable_decl, [Tree(variable, [Tree(type, [Token(TYPE, 'int')]), Token(IDENT, 'n')])]), Tree(stmt, [Tree(ass, [Tree(var_addr, [Token(IDENT, 'n')]), Tree(expr, [Tree(expr8, [Tree(expr1, [Tree(expr2, [Tree(expr3, [Tree(expr4, [Tree(expr5, [Tree(expr6, [Tree(val, [Tree(subscript, [Tree(val, [Tree(var_addr, [Token(IDENT, 'items')])]), Tree(expr, [Tree(expr8, [Tree(expr1, [Tree(expr2, [Tree(expr3, [Tree(expr4, [Tree(expr5, [Tree(neg, [Tree(expr6, [Tree(expr7, [Tree(const_int, [Token(INT, '2')])])])])])])])])])])])])])])])])])])])])])])]), Tree(stmt, [Tree(for_stmt, [Tree(ass, [Tree(var_addr, [Token(IDENT, 'i')]), Tree(expr, [Tree(expr8, [Tree(expr1, [Tree(expr2, [Tree(expr3, [Tree(expr4, [Tree(expr5, [Tree(expr6, [Tree(expr7, [Tree(const_int, [Token(INT, '0')])])])])])])])])])])]), Tree(expr, [Tree(expr8, [Tree(expr1, [Tree(expr2, [Tree(lt, [Tree(expr3, [Tree(expr4, [Tree(expr5, [Tree(expr6, [Tree(val, [Tree(var_addr, [Token(IDENT, 'i')])])])])])]), Tree(sub, [Tree(expr4, [Tree(expr5, [Tree(expr6, [Tree(val, [Tree(var_addr, [Token(IDENT, 'n')])])])])]), Tree(expr5, [Tree(expr6, [Tree(expr7, [Tree(const_int, [Token(INT, '1')])])])])])])])])])]), Tree(ass, [Tree(var_addr, [Token(IDENT, 'i')]), Tree(expr, [Tree(expr8, [Tree(expr1, [Tree(expr2, [Tree(expr3, [Tree(add, [Tree(expr4, [Tree(expr5, [Tree(expr6, [Tree(val, [Tree(var_addr, [Token(IDENT, 'i')])])])])]), Tree(expr5, [Tree(expr6, [Tree(expr7, [Tree(const_int, [Token(INT, '1')])])])])])])])])])])]), Tree(stmt, [Tree(stmt_block, [])])])])])])

"""
