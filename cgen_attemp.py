from copy import deepcopy

import lark
from lark import Lark, Tree
from lark.visitors import Interpreter

from symbol_table_creation_attemp import symbol_table, set_inheritance, ClassTreeSetter, \
    class_type_objects, class_table, ImplicitThis
from symbol_table_creation_attemp import symbol_table_objects, function_objects, \
    function_table, grammar, SymbolTableMaker, Type


def pop_scope(scope):
    scopes = scope.split('/')
    scopes.pop()
    parent_scope = '/'.join(scopes)
    return parent_scope


def tab(code) -> str:
    codes = code.split('\n')
    if len(codes[0]) == 0:
        codes = codes[1:]
    remove = 0
    for char in codes[0]:
        if char == ' ':
            remove += 1
        else:
            break
    for i in range(len(codes)):
        codes[i] += '\n'
        line = codes[i]
        if line[:remove] == ' ' * remove:
            codes[i] = line[remove:]
    if codes[-1][-1] != '\n':
        codes[-1][-1] += '\n'
    return ''.join(codes)


class Types:
    BOOL = 'bool'
    INT = 'int'
    STRING = 'string'
    DOUBLE = 'double'


def cnt():
    CodeGenerator.LabelCnt += 1
    return CodeGenerator.LabelCnt


def cast_cgen():
    code = ''
    code += tab(""" # ITOD
             .data
                 .align 2
                 root_itod_ival: .space 4
             .text
                 root_itod:
                 la $t0, root_itod_ival
                 sub $sp, $sp, 8
                 sw $t0, 0($sp)

                 lw $t0, 0($sp)
                 lw $t0, 0($t0)
                 sw $t0, 0($sp)

                 mtc1.d $t0, $f0
                 cvt.d.w $f0, $f0


                 sub $sp, $sp, 8
                 s.d $f0, 0($sp)

                 l.d   $f30, 0($sp)
                 addi $sp, $sp, 8
                 addi $sp, $sp, 8
                 addi $sp, $sp, -8
                 s.d   $f30, 0($sp)
                 jr   $ra
             """)

    code += tab(
        """
        #DTOI
        root_dtoi_:
        .data
        .align 2
        root_dtoi__dval: .space 8
        .text
            li $t0, 1
            sub $sp, $sp, 8
            sw $t0, 0($sp)

            la $t0, root_dtoi__dval
            sub $sp, $sp, 8
            sw $t0, 0($sp)
            lw $t0, 0($sp)
            l.d $f0, 0($t0)


            li.d $f6, 0.5 # round to nearest integer
            add.d $f0, $f0, $f6

            cvt.w.d $f0,$f0
            mfc1.d $a0,$f0
            sw $a0, 0($sp)


            l.d   $f30, 0($sp)
            addi $sp, $sp, 8
            addi $sp, $sp, 8

            addi $sp, $sp, -8
            s.d   $f30, 0($sp)
            jr   $ra

        """
    )

    code += tab(
        """
        # ceil
        root_ceil__:
        .data
        .align 2
        root_ceil___dval: .space 8
        .text
            li $t0, 1
            sub $sp, $sp, 8
            sw $t0, 0($sp)

            la $t0, root_ceil___dval
            sub $sp, $sp, 8
            sw $t0, 0($sp)
            lw $t0, 0($sp)
            l.d $f0, 0($t0)


            # li.d $f6, 0.5 # round to nearest integer
            # add.d $f0, $f0, $f6

            cvt.w.d $f0,$f0
            mfc1.d $a0,$f0
            sw $a0, 0($sp)


            l.d   $f30, 0($sp)
            addi $sp, $sp, 8
            addi $sp, $sp, 8

            addi $sp, $sp, -8
            s.d   $f30, 0($sp)
            jr   $ra

        """
    )

    code += tab(  # generated by cgen
        """
        .text
        root_itob:
        .data
        .align 2
            root_itob_ival: .space 4
        .text
            la $t0, root_itob_ival
            sub $sp, $sp, 8
            sw $t0, 0($sp)
            lw $t0, 0($sp)
            lw $t0, 0($t0)
            sw $t0, 0($sp)
            li $t0, 0
            sub $sp, $sp, 8
            sw $t0, 0($sp)
            lw $t0, 0($sp)
            lw $t1, 8($sp)
            sne $t2, $t1, $t0
            sw $t2, 8($sp)
            addi $sp, $sp, 8
            l.d   $f30, 0($sp)
            addi $sp, $sp, 8
            addi $sp, $sp, -8
            s.d   $f30, 0($sp)
            jr   $ra
        """
    )
    code += tab(  # generated by cgen
        """
        .text
        root_btoi:
        .data
        .align 2
        root_btoi_bval: .space 4
        .text
        start_btoi_stmt_1:
        start_btoi_stmt_2:
        # if starts here:
        .text
            la $t0, root_btoi_bval
            sub $sp, $sp, 8
            sw $t0, 0($sp)
            lw $t0, 0($sp)
            lw $t0, 0($t0)
            sw $t0, 0($sp)
            lw $a0, 0($sp)
            addi $sp, $sp, 8
            beq $a0, 0, end_btoi_stmt_3
            j  start_btoi_stmt_3
        start_btoi_stmt_3:
        start_btoi_stmt_4:
        start_btoi_stmt_5:
            li $t0, 1
            sub $sp, $sp, 8
            sw $t0, 0($sp)

            l.d   $f30, 0($sp)
            addi $sp, $sp, 8
            addi $sp, $sp, -8
            s.d   $f30, 0($sp)
            jr   $ra
        end_btoi_stmt_5:
        end_btoi_stmt_4:
        end_btoi_stmt_3:
        end_btoi_stmt_2:
        start_btoi_stmt_6:
        .text
            li $t0, 0
            sub $sp, $sp, 8
            sw $t0, 0($sp)

            l.d   $f30, 0($sp)
            addi $sp, $sp, 8
            addi $sp, $sp, -8
            s.d   $f30, 0($sp)
            jr   $ra

        end_btoi_stmt_6:
        end_btoi_stmt_1:
        """
    )
    return code


class CodeGenerator(Interpreter):
    current_scope = 'root'
    block_stmt_counter = 0
    str_const = 0
    LabelCnt = 0
    class_cnt = 0
    """we need a way to store which local_variable do we have in our current scope so that in case of recursive
    call save the prior values of local_vars. protocol of this stack is in the following order:
    - in the entering of a stmt_block we push every variable_decl consist of [full scope name, type]
    - in the exiting of a stmt_block we pop last N elements which N is the number of variable_decl in that stmt_block
    - before return which is equivalent to 'jr $ra', we pop last N elements which N is number of variable_decl we have
        seen until now"""
    stack_local_params = []
    """this stack save number of variable_decl we have seen until now. protocol of this stack is in the following order:
    - last element ++1 when entering a new stmt_block for each variable_decl
    - last element --N when exiting a stmt_block which N is the number of variable_decl in that stmt_block
    - before every function call which is equivalent to 'jal f_label', we append 0 to stack
    - before every return which is equivalent to 'jr $ra', we pop last element of stack   
    """
    stack_local_params_count = [0]

    def __init__(self):
        super().__init__()
        self.expr_types = []
        self.stmt_labels = []
        self.loop_labels = []
        self.last_type = None

    def start(self, tree):
        return ''.join(self.visit_children(tree))

    def decl(self, tree):
        code = ''
        for decl in tree.children:
            if decl.data == 'variable_decl' or decl.data == 'function_decl':
                code += self.visit(decl)
            elif decl.data == 'class_decl':
                code += self.visit(decl)
        return code

    def class_inst(self, tree):
        class_name = tree.children[0].value
        class_obj = class_type_objects[class_table[class_name]]
        size = 8 + len(class_obj.variables) * 8
        self.expr_types.append(Type(name=class_name))
        code = ''
        code += '.text\n'
        code += '\tli $a0, {}\n'.format(size)
        code += '\tli $v0, 9\n'
        code += '\tsyscall\n'
        code += '\tlw $t0, {}\n'.format(class_name + '_vtable')
        code += '\tsw $t0, 0($v0)\n'
        code += '\taddi $sp, $sp, -8\n'
        code += '\tsw $v0, 0($sp)\n'
        return code

    def function_decl(self, tree):
        code = ''
        if len(tree.children) == 4:
            ident = tree.children[1]
            formals = tree.children[2]
            stmt_block = tree.children[3]
        else:
            ident = tree.children[0]
            formals = tree.children[1]
            stmt_block = tree.children[2]

        if ident == 'main':
            code += (
                '.text\n'
                '__strcmp__:\n'
                '\tlb $t0, 0($a0)\n'
                '\tlb $t1, 0($a1)\n'
                '\tbne $t0, $t1, __NE__\n'
                '\tbne $t0, $zero, __cont__\n'
                '\tli $v0, 1\n'
                '\tjr $ra\n'
                '__cont__:\n'
                '\taddi $a0, $a0, 1\n'
                '\taddi $a1, $a1, 1\n'
                '\tj __strcmp__\n'
                '__NE__:\n'
                '\tli $v0, 0\n'
                '\tjr $ra\n\n'
                '.data\n'
                '.align 2\n'
                '\ttrue: .asciiz "true"\n'
                '\tfalse: .asciiz "false"\n'
                '\tpconst10000: .double 10000.0\n'
                '\tnw: .asciiz "\\n"\n'
                '\tsign_double: .asciiz "-"\n'
                '\t__const_0_5__: .double 0.5\n'
            )
            code += cast_cgen()
            code += ('.text\n'
                     'main:\n')
            for cl in range(len(class_table)):
                code += '\tjal __init__vtable_{}\n'.format(cl)
            code += '\tla\t$ra,__end__\n'
        else:
            code += '.text\n{}:\n'.format((self.current_scope + '/' + ident).replace('/', '_'))

        self.current_scope += "/" + ident.value
        code += self.visit(formals)

        self.current_scope += "/_local"
        self.stack_local_params_count.append(0)

        if ident != 'main':
            return_stmt = Tree(data='stmt', children=[Tree(data='return_stmt', children=[])])
            stmt_block._meta = return_stmt

        code += self.visit(stmt_block)

        local_var_count = self.stack_local_params_count[-1]
        self.stack_local_params = self.stack_local_params[:-local_var_count]
        self.stack_local_params_count.pop()
        self.current_scope = pop_scope(self.current_scope)  # pop _local
        self.current_scope = pop_scope(self.current_scope)  # pop formals
        # code += "jr $ra\n"

        if ident == 'main':
            code += '.text\n'
            code += '__end__:\n'
            code += '\tli $v0, 10\t\t\t#exit\n'
            code += '\tsyscall\n'
        return code

    def formals(self, tree):
        code = ''
        for variable in tree.children:
            formal_name = variable.children[1].value
            formal_type = symbol_table_objects[symbol_table[(self.current_scope, formal_name)]].type
            code += '.data\n'
            code += '.align 2\n'
            if formal_type.name == 'double' and formal_type.dimension == 0:
                code += '{}: .space 8\n'.format((self.current_scope + "/" + formal_name).replace("/", "_"))
            else:
                code += '{}: .space 4\n'.format((self.current_scope + "/" + formal_name).replace("/", "_"))
        return code

    def stmt_block(self, tree):
        self.current_scope += "/" + str(self.block_stmt_counter)
        self.block_stmt_counter += 1
        code = ''
        stmt_id = cnt()
        store_len = len(self.stmt_labels)
        code += '.text\nstart_stmt_{}:\n'.format(stmt_id)

        if type(tree._meta) == lark.tree.Tree:
            return_stmt = tree._meta
            tree.children.append(return_stmt)

        for child in tree.children:
            if child.data == 'variable_decl':
                code += self.visit(child)
                self.stack_local_params_count[-1] += 1
                variable_name = child.children[0].children[1].value
                variable_type = symbol_table_objects[
                    symbol_table[(self.current_scope, variable_name)]].type  # TODO is current_scope set?
                self.stack_local_params.append(
                    [self.current_scope + "/" + variable_name, variable_type])
                code += '.text\n'
                if variable_type.name == 'double' and variable_type.dimension == 0:
                    code += '\tl.d  $f0, {}\n'.format((self.current_scope + "/" + variable_name).replace("/", "_"))
                    code += '\taddi $sp, $sp, -8\n'
                    code += '\ts.d  $f0, 0($sp)\n\n'
                else:
                    code += '\tla   $t0, {}\n'.format((self.current_scope + "/" + variable_name).replace("/", "_"))
                    code += '\tlw   $t1, 0($t0)\n'
                    code += '\taddi $sp, $sp, -8\n'
                    code += '\tsw   $t1, 0($sp)\n\n'
            else:
                code += self.visit(child)

        # pop declared variables in this scope
        for child in reversed(tree.children):
            if child.data == 'variable_decl':
                self.stack_local_params_count[-1] -= 1
                variable_name = child.children[0].children[1].value
                variable_type = symbol_table_objects[symbol_table[(self.current_scope, variable_name)]].type
                self.stack_local_params.pop()
                code += '.text\n'
                if variable_type.name == 'double' and variable_type.dimension == 0:
                    code += '\tl.d  $f0, 0($sp)\n'
                    code += '\taddi $sp, $sp, 8\n'
                    code += '\ts.d  $f0, {}\n\n'.format((self.current_scope + "/" + variable_name).replace("/", "_"))
                else:
                    code += '\tlw   $t1, 0($sp)\n'
                    code += '\taddi $sp, $sp, 8\n'
                    code += '\tla   $t0, {}\n'.format((self.current_scope + "/" + variable_name).replace("/", "_"))
                    code += '\tsw   $t1, 0($t0)\n\n'

        code += 'end_stmt_{}:\n'.format(stmt_id)
        self.stmt_labels = self.stmt_labels[:store_len]
        self.stmt_labels.append(stmt_id)
        self.current_scope = pop_scope(self.current_scope)
        return code

    def stmt(self, tree):
        child = tree.children[0]
        store_len = len(self.stmt_labels)
        code = ''
        if child.data == 'for_stmt':
            if child.children[0].data == 'ass':
                code += self.visit(child.children[0])
                code += '\taddi $sp, $sp, 8\n'

        stmt_id = cnt()
        code += ('start_stmt_{}:\n'.format(stmt_id))

        child._meta = stmt_id

        if child.data == 'if_stmt':
            code += self.visit(child)
        elif child.data == 'while_stmt':
            code += self.visit(child)
        elif child.data == 'for_stmt':
            code += self.visit(child)
        elif child.data == 'stmt_block':
            code += self.visit(child)
        elif child.data == 'break_stmt':  # there is a problem with it !
            code += self.visit(child)
        elif child.data == 'return_stmt':
            # raise Exception()
            code += self.visit(child)
            # todo implement for class methods
            # todo is it really done?
            func_name = ''
            if '__class__' in self.current_scope:
                func_name = self.current_scope.split('/')[2]
                class_name = self.current_scope.split('/')[1][9:]
                funct = class_type_objects[class_table[class_name]].find_function(func_name)
            else:
                func_name = self.current_scope.split('/')[1]
                funct = function_objects[function_table[func_name]]

            if funct.return_type.name == 'double' and funct.return_type.dimension == 0:
                code += '\tl.d   $f30, 0($sp)\n'
                code += '\taddi $sp, $sp, 8\n'
            elif funct.return_type.name != 'void':
                code += '\tlw   $t8, 0($sp)\n'
                code += '\taddi $sp, $sp, 8\n'
            # todo wither is it essential to pop expr from stack or not or do this in caller side?
            local_var_count_of_this_scope = self.stack_local_params_count[-1]
            for local_var in reversed(self.stack_local_params[-local_var_count_of_this_scope:]):
                local_var_name = local_var[0]
                local_var_type = local_var[1]
                code += '.text\n'
                if local_var_type.name == 'double' and local_var_type.dimension == 0:
                    code += '\tl.d  $f0, 0($sp)\n'
                    code += '\taddi $sp, $sp, 8\n'
                    code += '\ts.d  $f0, {}\n\n'.format(local_var_name.replace("/", "_"))
                else:
                    code += '\tlw   $t0, 0($sp)\n'
                    code += '\taddi $sp, $sp, 8\n'
                    code += '\tsw   $t0, {}\n\n'.format(local_var_name.replace("/", "_"))
            # self.stack_local_params = self.stack_local_params[:-local_var_count_of_this_scope]
            # self.stack_local_params_count.pop()
            if funct.return_type.name == 'double' and funct.return_type.dimension == 0:
                code += '\taddi $sp, $sp, -8\n'
                code += '\ts.d   $f30, 0($sp)\n'
            elif funct.return_type.name != 'void':
                code += '\taddi $sp, $sp, -8\n'
                code += '\tsw   $t8, 0($sp)\n'
            code += '\tjr   $ra\n\n'
        elif child.data == 'print_stmt':
            code += self.visit(child)
        elif child.data == 'expr' or child.data == 'ass':
            code += self.visit(child)
            expr_type = self.expr_types[-1]
            if expr_type.name != 'void':
                code += '.text\n'
                code += '\taddi\t$sp, $sp, 8\n\n'
            self.expr_types.pop()
        else:
            code += self.visit(child)
        # if child.data == 'for_stmt':
        #     for for_child in child.children:
        #         if for_child.data == 'ass' or for_child.data == 'expr':
        #             print('yes')
        #             pass

        code += 'end_stmt_{}:\n'.format(stmt_id)
        self.stmt_labels = self.stmt_labels[:store_len]
        self.stmt_labels.append(stmt_id)
        return code

    def break_stmt(self, tree):
        code = tab("""
            .text\t\t\t\t# break
                j end_stmt_{}
            ##             
        """.format(self.loop_labels[-1]))
        return code

    def return_stmt(self, tree):
        return ''.join(self.visit_children(tree))

    def if_stmt(self, tree):
        code = '# if starts here:\n'
        code += self.visit(tree.children[0])

        then_label = cnt()
        else_label = cnt()

        """
        if (true)
            a = b;
        """

        then_code = self.visit(tree.children[1])
        else_code = '' if len(tree.children) == 2 else self.visit(tree.children[2])
        if len(tree.children) == 2:
            code += tab(
                """
                .text\t\t\t\t#If
                    lw $a0, 0($sp)
                    addi $sp, $sp, 8
                    beq $a0, 0, end_stmt_{then}
                    j  start_stmt_{then}
                """.format(then=then_label)
            )
            code += '\tstart_stmt_{}:\n'.format(then_label)
            code += then_code
            code += '\tend_stmt_{}:\n'.format(then_label)
        else:
            code += tab("""
                .text\t\t\t\t# IfElse
                    lw $a0, 0($sp)
                    addi $sp, $sp, 8
                    beq $a0, 0, start_stmt_{els}
                """.format(els=else_label))
            code += '\tstart_stmt_{}:\n'.format(then_label)
            code += then_code
            code += '\tend_stmt_{}:\n'.format(then_label)
            code += tab("j end_stmt_{els}".format(els=else_label))
            code += '\tstart_stmt_{}:\n'.format(else_label)
            code += else_code
            code += '\tend_stmt_{}:\n'.format(else_label)
        return code

    def while_stmt(self, tree):
        while_id = tree._meta
        self.loop_labels.append(while_id)
        store_len = len(self.stmt_labels)
        code = '.text\t\t\t\t# While\n'
        code += self.visit(tree.children[0])
        stmt_code = self.visit(tree.children[1])
        code += tab("""
            lw $a0, 0($sp)
            addi $sp, $sp, 8
            beq $a0, 0, end_stmt_{while_end}
        """.format(while_end=while_id))
        code += stmt_code
        code += tab("j start_stmt_{while_start}".format(while_start=while_id))
        self.stmt_labels = self.stmt_labels[:store_len]
        self.loop_labels.pop()
        return code

    def for_stmt(self, tree):
        code = '.text\t\t\t\t# For\n'  # todo check this comment
        for_id = tree._meta
        self.loop_labels.append(for_id)
        children = tree.children
        next = ''
        if children[0].data == 'ass':
            code += self.visit(children[1])
        else:
            code += self.visit(children[0])
        if children[-2].data == 'ass':
            next += self.visit(children[-2])
            next += '\taddi $sp, $sp, 8\n'
        code += tab("""
            lw $a0, 0($sp)
            addi $sp, $sp, 8
            beq $a0, $zero, end_stmt_{}
        """.format(for_id))
        code += self.visit(children[-1])
        code += next
        code += "\tj start_stmt_{}\n".format(for_id)
        self.loop_labels.pop()
        return code

    # probably we wont need this part in cgen
    def class_decl(self, tree):
        code = ''
        ident = tree.children[0]
        self.current_scope += "/__class__" + ident.value

        class_object = class_type_objects[class_table[ident.value]]
        code += '.data\n'
        code += '.align 2\n'
        code += '{}: .space 4\n'.format(class_object.name + '_vtable')
        code += '.text\n'
        code += '__init__vtable_{}:\n'.format(self.class_cnt)
        code += '\tli $a0, {}\n'.format(len(class_object.functions) * 4)
        code += '\tli $v0, 9\n'
        code += '\tsyscall\n'
        code += '\tsw $v0, {}\n'.format(class_object.name + '_vtable')
        self.class_cnt += 1
        counter = 0
        for func in class_object.functions:
            code += '\tla $t0, {}\n'.format(func.exact_name.replace('/', '_'))
            code += '\tsw $t0, {}($v0)\n'.format(counter)
            counter += 4
        code += '\tjr $ra\n'

        if len(tree.children) > 1:
            if type(tree.children[1]) == lark.lexer.Token:
                for field in tree.children[2:]:
                    if field.children[0].data == 'function_decl':
                        code += self.visit(field)
            else:
                for field in tree.children[1:]:
                    if field.children[0].data == 'function_decl':
                        code += self.visit(field)

        self.current_scope = pop_scope(self.current_scope)
        return code

    def field(self, tree):
        code = ''
        for child in tree.children:
            if child.data == 'function_decl':
                code += self.visit(child)
                pass
        return code

    def variable_decl(self, tree):
        code = ''
        variable = tree.children[0]
        var_type = variable.children[0]
        size = 4
        if type(var_type.children[0]) == lark.lexer.Token:
            var_type = var_type.children[0].value
            if var_type == 'double':
                size = 8
            elif var_type == 'string':
                code += '.data\n'
                code += '.align 2\n'
                code += self.current_scope.replace('/', '_') + '_' + variable.children[1] + ': .space ' + str(
                    size) + '\n'
                code += '.text\n'
                code += '\tli $a0, 256\n'
                code += '\tli $v0, 9\n'
                code += '\tsyscall\n'
                code += '\tsw $v0, ' + self.current_scope.replace('/', '_') + '_' + variable.children[1] + '\n\n'
                return code
        name = variable.children[1]
        code += '.data\n'
        code += '.align 2\n'
        code += self.current_scope.replace('/', '_') + '_' + name + ': .space ' + str(size) + '\n\n'
        return code

    def type(self, tree):
        if type(tree.children[0]) == lark.lexer.Token:
            self.last_type = Type(tree.children[0])
        else:
            self.visit(tree.children[0])
            self.last_type.dimension += 1
        return ''

    def expr(self, tree):
        return ''.join(self.visit_children(tree))

    def expr8(self, tree):
        return ''.join(self.visit_children(tree))

    def expr1(self, tree):
        return ''.join(self.visit_children(tree))

    def expr2(self, tree):
        return ''.join(self.visit_children(tree))

    def expr3(self, tree):
        return ''.join(self.visit_children(tree))

    def expr4(self, tree):
        return ''.join(self.visit_children(tree))

    def expr5(self, tree):
        return ''.join(self.visit_children(tree))

    def expr6(self, tree):
        return ''.join(self.visit_children(tree))

    def expr7(self, tree):
        child_codes = self.visit_children(tree)
        if len(child_codes) == 0:
            return ''
        return ''.join(child_codes)

    def read_line(self, tree):
        code = tab("""
        .text\t\t\t\t # Read Line
            li $a0, 256         #Maximum string length
            li $v0, 9           #sbrk
            syscall
            sub $sp, $sp, 8
            sw $v0, 0($sp)
            move $a0, $v0
            li $a1, 256         #Maximum string length (incl. null)
            li $v0, 8           #read_string
            syscall             #ReadLine()
            
            lw $a0, 0($sp)      #Replace \\n to \\r(?)
            lb $t1, nw
            
            # li $v0, 1
            # addi $a0, $t1, 0
            # syscall
            
            # li $v0, 10
            # syscall
            
            
            read_{label_id}:
                lb $t0, 0($a0)
                
                # addi $a3, $a0, 0
                # 
                # li $a0, '$'
                # li $v0, 11
                # syscall
                # 
                # 
                # addi $a0, $t0, 0
                # li $v0, 1
                # syscall
                # 
                # li $a0, ' '
                # li $v0, 11
                # syscall
                # 
                # li $a0, '$'
                # li $v0, 11
                # syscall
                # 
                # 
                # addi $a0, 0
                # addi $a0, $a3, 0

                beq $t0, 0, e_read_{label_id}
                bne $t0, 10, ten_{ten}
                li $t2, 0
                sb $t2, 0($a0)
                ten_{ten}:
                
                bne $t0, 13, thirt_{thirt}
                li $t2, 0
                sb $t2, 0($a0)
                thirt_{thirt}:
                
                
                addi $a0, $a0, 1
                j read_{label_id}
            e_read_{label_id}:
                # # lb $t2, 1($a0)
                # li $t2, 0
                # sb $t2, -1($a0)

            
            # li $v0, 10
            # lw $a0, 0($sp)
            # syscall

        ##
        """.format(label_id=cnt(), ten=cnt(), thirt=cnt()))
        self.expr_types.append(Type(Types.STRING))
        return code

    def read_integer(self, tree):
        code = tab("""
            .text\t\t\t\t # Read Integer
                li $v0, 5           #read_integer
                syscall             #ReadInteger()
                sub $sp, $sp, 8
                sw $v0, 0($sp)
            ##
            """)
        self.expr_types.append(Type(Types.INT))
        return code

    def read_char(self, tree):
        code = tab("""
             .text\t\t\t\t # Read Integer
                 li $v0, 12           #read_char
                 syscall             #ReadChar
                 sub $sp, $sp, 8
                 sw $v0, 0($sp)
             ##
             """)
        self.expr_types.append(Type(Types.INT))
        return code

    def new_array(self, tree):
        code = ''
        code += ''.join(self.visit_children(tree))
        shamt = 2
        tp = tree.children[1].children[0]
        if type(tp) == lark.lexer.Token:
            if tp.value == Types.DOUBLE:
                shamt = 3
        """
        we store size of array in 8 bytes before start pointer of array
        """
        code += tab("""
            .text\t\t\t\t # New array
                lw $a0, 0($sp)
                addi $sp, $sp, 8
                addi $t6, $a0, 0 # t6 is length of array
                sll $a0, $a0, {shamt}
                addi $a0, $a0, 8 # extra 8 bytes for length
                li $v0, 9           #rsbrk
                syscall
                sw $t6 0($v0)
                addi $v0, $v0, 8
                sub $sp, $sp, 8
                sw $v0, 0($sp)\n
            ##
        """.format(shamt=shamt))
        self.expr_types.append(Type(name=self.last_type.name, dimension=self.last_type.dimension + 1))
        return code

    def get_type(self, typ):
        if type(typ) == lark.lexer.Token:
            return Type(typ)
        ret = self.get_type(typ.children[0])
        ret.dimension += 1
        return ret

    def not_expr(self, tree):
        code = ''.join(self.visit_children(tree))
        code += tab("""
            .text\t\t\t\t # Not
                lw $t0, 0($sp)
                addi $sp, $sp, 8
                li $t1, 1
                beq $t0, 0, not_{0}
                    li $t1, 0
                not_{0}:
                    sub  $sp, $sp, 8
                    sw $t1, 0($sp)
            ##
        """.format(cnt()))
        self.expr_types.pop()
        self.expr_types.append(Type(Types.BOOL))
        return code

    def neg(self, tree):
        code = ''.join(self.visit_children(tree))
        typ = self.expr_types[-1]
        if typ.name == 'int':
            code += tab("""
                .text\t\t\t\t# Neg int
                    lw $t0, 0($sp)
                    sub $t0, $zero, $t0
                    sw $t0, 0($sp)
                ##
                """)
        else:
            code += tab("""
                .text\t\t\t\t# Neg double
                    l.d $f0, 0($sp)
                    neg.d $f0, $f0
                    s.d $f0, 0($sp)
                ##
            """)
        return code

    def print(self, tree):
        code = ''
        for child in tree.children[0].children:
            code += self.visit(child)
            t = self.expr_types[-1]
            self.expr_types.pop()
            code += '.text\n'
            if t.name == 'double':
                # code += tab("""
                #
                #
                #
                #     .text
                #         l.d $f6, 0($sp)
                #         addi $sp, $sp, 8
                #
                #     .text
                #         li.d $f8, 0.0
                #         c.le.d $f6, $f8
                #         bc1f __double_le__p__{sign_cnt}
                #         # Print -
                #             li $v0, 4
                #             la $a0, sign_double
                #             syscall\t\t\t\t#Print sign double\n
                #         ##
                #         neg.d $f6, $f6
                #         __double_le__p__{sign_cnt}:
                #
                #
                # 	.text
                #         l.d  $f0, root_print_double___x
                #         addi $sp, $sp, -8
                #         s.d  $f0, 0($sp)
                #
                #     .text
                #         sub $sp, $sp, 8
                #         s.d $f6, 0($sp)
                #
                #     .text
                #         l.d  $f0, 0($sp)
                #         s.d  $f0, root_print_double___x
                #         addi $sp, $sp, 8
                #
                #     .text
                #         addi $sp, $sp, -8
                #         sw   $ra, 0($sp)
                #         jal root_print_double__
                #         lw   $ra, 0($sp)
                #         addi $sp, $sp, 8
                #
                #         l.d  $f0, 0($sp)
                #         addi $sp, $sp, 8
                #         s.d  $f0, root_print_double___x
                # """.format(sign_cnt=cnt()))
                # # code += tab("""
                # #     l.d $f12, 0($sp)
                # #     addi $sp, $sp, 8
                # #     li $v0, 3
                # #     syscall
                # # """)
                code += tab("""
                    l.d $f12, 0($sp)
                    addi $sp, $sp, 8
                    cvt.s.d $f12, $f12
                    li $v0, 2
                    syscall
                """)
            #                 print("""
            # l.d $f12, 0($sp)
            # addi $sp, $sp, 8
            # li $v0, 3
            # syscall
            #                 """)
            elif t.name == 'int':
                code += tab("""
                    # Print int
                        li $v0, 1
                        lw $a0, 0($sp)
                        addi $sp, $sp, 8
                        syscall             #Print int
                    ##
                """)
            elif t.name == Types.STRING:
                code += tab(
                    """
                    # Print string
                        li $v0, 4
                        lw $a0, 0($sp)
                        addi $sp, $sp, 8
                        syscall             #Print string
                    ##
                    """)
            elif t.name == 'bool' and t.dimension == 0:
                code += tab(
                    """
                    # Print bool
                        lw $a0, 0($sp)
                        addi $sp, $sp, 8
                        beq $a0, 0, zero_{cnt}
                        li $v0, 4
                        la $a0, true
                        syscall
                        j ezero_{cnt}
                        zero_{cnt}:
                        li $v0, 4
                        la $a0, false
                        syscall             #Print bool
                        ezero_{cnt}:
                    ##
                    """.format(cnt=cnt())
                )
            # '\n' at the end of print
        code += tab(
            """
            # Print new line
                li $v0, 4
                la $a0, nw
                syscall\t\t\t\t#Print new line\n
            ##
            """)
        return code

    def const_int(self, tree):
        code = ''
        code += '.text\n'
        code += '\tli $t0, {}\n'.format(tree.children[0].value.lower())
        code += '\tsub $sp, $sp, 8\n'
        code += '\tsw $t0, 0($sp)\n\n'
        self.expr_types.append(Type('int'))
        return code

    def const_double(self, tree):
        code = ''
        dval = tree.children[0].value.lower()
        if dval[-1] == '.':
            dval += '0'
        if '.e' in dval:
            index = dval.find('.e') + 1
            dval = dval[:index] + '0' + dval[index:]
        code += '.text\n'
        code += '\tli.d $f0, {}\n'.format(dval)
        code += '\tsub $sp, $sp, 8\n'
        code += '\ts.d $f0, 0($sp)\n\n'
        self.expr_types.append(Type('double'))
        return code

    def const_bool(self, tree):
        code = ''
        code += '.text\n'
        code += '\tli $t0, {}\n'.format(int(tree.children[0].value == 'true'))
        code += '\tsub $sp, $sp, 8\n'
        code += '\tsw $t0, 0($sp)\n'
        self.expr_types.append(Type('bool'))
        return code

    def const_str(self, tree):
        code = ''
        code += '.data\n'
        code += '.align 2\n'
        code += '__const_str__{}: .asciiz {}\n'.format(self.str_const, tree.children[0].value)
        code += '.text\n'
        code += '\tla $t0, __const_str__{}\n'.format(self.str_const)
        code += '\tsub $sp, $sp, 8\n'
        code += '\tsw $t0, 0($sp)\n\n'
        self.str_const += 1
        self.expr_types.append(Type('string'))
        return code

    def add(self, tree):
        code = ''.join(self.visit_children(tree))
        typ = self.expr_types.pop()
        if typ.name == 'int':
            code += '.text\n'
            code += '\tlw $t0, 0($sp)\n'
            code += '\tlw $t1, 8($sp)\n'
            code += '\tadd $t2, $t1, $t0\n'
            code += '\tsw $t2, 8($sp)\n'
            code += '\taddi $sp, $sp, 8\n\n'
        else:
            code += '.text\n'
            code += '\tl.d $f0, 0($sp)\n'
            code += '\tl.d $f2, 8($sp)\n'
            code += '\tadd.d $f4, $f2, $f0\n'
            code += '\ts.d $f4, 8($sp)\n'
            code += '\taddi $sp, $sp, 8\n\n'
        return code

    def call(self, tree):
        # self.expr_types
        if len(tree.children) == 3:
            code = self.visit(tree.children[0])
            if self.expr_types[-1].dimension > 0:
                code += '.text\n'
                code += '\tlw $t0, 0($sp)\n'
                code += '\tlw $t0, -8($t0)\n'
                code += '\tsw $t0, 0($sp)\n\n'
                self.expr_types.pop()
                self.expr_types.append(Type(Types.INT))
                return code
            else:
                self.expr_types.pop()
                expr_class_inst = tree.children[0]
                ident = tree.children[1]
                actuals = tree.children[2]
                name = ident.value

                actuals._meta = [name, expr_class_inst]
                return self.visit(actuals)
            # for class
        if len(tree.children) == 2:
            # self.stack_local_params_count.append(0)
            ident = tree.children[0]
            actuals = tree.children[1]
            name = ident.value

            actuals._meta = [name, None]
            return self.visit(actuals)

    def method(self, tree):
        code = self.visit(tree.children[0])
        if self.expr_types[-1].dimension > 0:
            code += '.text\n'
            code += '\tlw $t0, 0($sp)\n'
            code += '\tlw $t0, -8($t0)\n'
            code += '\tsw $t0, 0($sp)\n\n'
            self.expr_types.pop()
            self.expr_types.append(Type(Types.INT))
            return code
        self.expr_types.pop()
        code = '.text\n'
        code += '\taddi $sp, $sp, -8\n'
        code += '\tsw $ra, 0($sp)\n'
        code += '\taddi $sp, $sp, -8\n'
        code += '\tsw $fp, 0($sp)\n'

        code += self.visit(tree.children[0])
        for ch in tree.children[2].children:
            code += self.visit(ch)

        code += self.visit(tree.children[0])
        class_type = self.expr_types.pop()
        function_name = tree.children[1].value
        index = class_type_objects[class_table[class_type.name]].find_function_index(function_name)
        code += '.text\t\t\t# method call {} {}\n'.format(class_type.name, function_name)
        code += '\tlw $t0, 0($sp)\n'
        code += '\taddi $sp, $sp, 8\n'
        code += '\tlw $t0, 0($t0)\n'
        code += '\taddi $t0, $t0, {}\n'.format(4 * index)
        code += '\tlw $t0, 0($t0)\n'
        code += '\taddi $fp, $sp, {}\n'.format(8 * len(tree.children[2].children))
        code += '\tjalr $t0\n'
        # code += '\tli $a0, 0\n'
        # code += '\tli $v0, 10\n'
        # code += '\tsyscall\n'
        # code += '\taddi $fp, $sp, -{}\n'.format(8 * len(tree.children[2].children))

        code += '.text\t # call {}\n'.format(function_name)
        function = class_type_objects[class_table[class_type.name]].functions[index]
        if function.return_type.name == 'double' and function.return_type.dimension == 0:
            code += '\tl.d   $f30, 0($sp)\n'
            code += '\taddi $sp, $sp, 8\n'
        elif function.return_type.name != 'void':
            code += '\tlw   $t8, 0($sp)\n'
            code += '\taddi $sp, $sp, 8\n'
        code += '\taddi $sp, $sp, {}\n'.format(len(tree.children[2].children) * 8 + 8)
        for i in range(len(tree.children[2].children)):
            self.expr_types.pop()
        code += '\tlw $fp, 0($sp)\n'
        code += '\taddi $sp, $sp, 8\n'
        code += '\tlw $ra, 0($sp)\n'
        code += '\taddi $sp, $sp, 8\n'
        if function.return_type.name == 'double' and function.return_type.dimension == 0:
            code += '\taddi $sp, $sp, -8\n'
            code += '\ts.d   $f30, 0($sp)\n'
        elif function.return_type.name != 'void':
            code += '\taddi $sp, $sp, -8\n'
            code += '\tsw   $t8, 0($sp)\n'
        self.expr_types.append(deepcopy(function.return_type))
        return code

    def actuals(self, tree):
        code = '.text\n'
        function_name = tree._meta[0]
        if tree._meta[1]:
            print("wtf?")
            expr = tree._meta[1]
            tmp = self.visit(expr)
            class_type = self.expr_types[-1]
            self.expr_types.pop()
            function_scope = 'root/__class__' + class_type.name + '/' + function_name
            function = class_type_objects[class_table[class_type.name]].find_function(name=function_name)
        else:
            function_scope = 'root/' + function_name
            function = function_objects[function_table[function_name]]

        # push formal parameter
        for formal in function.formals:
            exact_name = function_scope
            if tree._meta[1]:
                tmp = self.visit(tree._meta[1])
                class_type = self.expr_types[-1]
                self.expr_types.pop()
                for funct in class_type_objects[class_table[class_type.name]].functions:
                    if funct.name == function_name:
                        exact_name = funct.exact_name
            formal_name = (exact_name + "/" + formal[0]).replace("/", "_")
            formal_type = formal[1]
            if formal_type.name == 'double' and formal_type.dimension == 0:
                code += '\tl.d  $f0, {}\n'.format(formal_name)
                code += '\taddi $sp, $sp, -8\n'
                code += '\ts.d  $f0, 0($sp)\n\n'
            else:
                code += '\tlw   $t1, {}\n'.format(formal_name)
                code += '\taddi $sp, $sp, -8\n'
                code += '\tsw   $t1, 0($sp)\n\n'

        # set actual parameters to formal parameters
        if tree._meta[1]:
            exact_name = function_scope
            if tree._meta[1]:
                tmp = self.visit(tree._meta[1])
                class_type = self.expr_types[-1]
                self.expr_types.pop()
                for funct in class_type_objects[class_table[class_type.name]].functions:
                    if funct.name == function_name:
                        exact_name = funct.exact_name
            formal_name = (exact_name + "/" + function.formals[0][0]).replace("/", "_")
            # set 'this'
            # todo is it really a pointer or it's just a name?
            expr = tree._meta[1]
            code += self.visit(expr)
            # formal_name = function.formals[0][0]
            code += '.text\n'
            code += '\tlw $v0, 0($sp)\n'  # we don't use type because we are sure that it's class
            # code += '\tsw $v0, {}\n'.format((function_scope + "/" + formal_name).replace("/", "_"))
            code += '\tsw $v0, {}\n'.format(formal_name)
            code += '\taddi $sp, $sp, 8\n'
            self.expr_types.pop()
            actual_counter = 1
        else:
            actual_counter = 0

        for expr in tree.children:
            exact_name = function_scope
            if tree._meta[1]:
                tmp = self.visit(tree._meta[1])
                class_type = self.expr_types[-1]
                self.expr_types.pop()
                for funct in class_type_objects[class_table[class_type.name]].functions:
                    if funct.name == function_name:
                        exact_name = funct.exact_name
            code += self.visit(expr)
            formal_name = (exact_name + "/" + function.formals[actual_counter][0]).replace("/", "_")
            # formal_name = function.formals[actual_counter][0]
            code += '.text\n'
            formal_type = function.formals[actual_counter][1]
            if formal_type.name == 'double' and formal_type.dimension == 0:
                code += '\tl.d  $f0, 0($sp)\n'
                # code += '\ts.d  $f0, {}\n'.format((function_scope + "/" + formal_name).replace("/", "_"))
                code += '\ts.d  $f0, {}\n'.format(formal_name)
                code += '\taddi $sp, $sp, 8\n\n'
            else:
                code += '\tlw   $v0, 0($sp)\n'
                # code += '\tsw   $v0, {}\n'.format((function_scope + "/" + formal_name).replace("/", "_"))
                code += '\tsw   $v0, {}\n'.format(formal_name)  # herererere
                code += '\taddi $sp, $sp, 8\n\n'
            actual_counter += 1
            self.expr_types.pop()  # todo check f(double, double) + g(double, double) f: int g: int

        code += '.text\n'
        code += '\taddi $sp, $sp, -8\n'
        code += '\tsw   $ra, 0($sp)\n'

        if tree._meta[1]:  # E1.ident(E1, expr, expr, ...)
            expr = tree._meta[1]
            code += self.visit(expr)
            class_type = self.expr_types[-1]
            self.expr_types.pop()
            index = class_type_objects[class_table[class_type.name]].find_function_index(function_name)
            code += '.text\n'
            code += '\tlw $t0, 0($sp)\n'
            code += '\taddi $sp, $sp, 8\n'
            code += '\tlw $t0, 0($t0)\n'
            code += '\taddi $t0, $t0, {}\n'.format(4 * index)
            code += '\tlw $t0, 0($t0)\n'
            code += '\tjalr $t0\n'
        else:
            label_name = function.exact_name
            code += '\tjal {}\n'.format(label_name.replace('/', '_'))

        if function.return_type.name == 'double' and function.return_type.dimension == 0:
            code += '\tl.d   $f30, 0($sp)\n'
            code += '\taddi $sp, $sp, 8\n'
        elif function.return_type.name != 'void':
            code += '\tlw   $t8, 0($sp)\n'
            code += '\taddi $sp, $sp, 8\n'

        code += '\tlw   $ra, 0($sp)\n'
        code += '\taddi $sp, $sp, 8\n\n'

        # pop formal parameters
        for formal in reversed(function.formals):
            exact_name = function_scope
            if tree._meta[1]:
                tmp = self.visit(tree._meta[1])
                class_type = self.expr_types[-1]
                self.expr_types.pop()
                for funct in class_type_objects[class_table[class_type.name]].functions:
                    if funct.name == function_name:
                        exact_name = funct.exact_name
            formal_name = (exact_name + "/" + formal[0]).replace("/", "_")
            formal_type = formal[1]
            if formal_type.name == 'double' and formal_type.dimension == 0:
                code += '\tl.d  $f0, 0($sp)\n'
                code += '\taddi $sp, $sp, 8\n'
                code += '\ts.d  $f0, {}\n\n'.format(formal_name)
            else:
                code += '\tlw   $t0, 0($sp)\n'
                code += '\taddi $sp, $sp, 8\n'
                code += '\tsw   $t0, {}\n\n'.format(formal_name)
        if function.return_type.name == 'double' and function.return_type.dimension == 0:
            code += '\taddi $sp, $sp, -8\n'
            code += '\ts.d   $f30, 0($sp)\n'
        elif function.return_type.name != 'void':
            code += '\taddi $sp, $sp, -8\n'
            code += '\tsw   $t8, 0($sp)\n'
        code += '# return type is ' + function.return_type.name + ' ' + str(function.return_type.dimension)
        code += '\n'
        self.expr_types.append(deepcopy(function.return_type))
        return code

    def sub(self, tree):
        code = ''.join(self.visit_children(tree))
        typ = self.expr_types.pop()
        if typ.name == 'int':
            code += '.text\n'
            code += '\tlw $t0, 0($sp)\n'
            code += '\tlw $t1, 8($sp)\n'
            code += '\tsub $t2, $t1, $t0\n'
            code += '\tsw $t2, 8($sp)\n'
            code += '\taddi $sp, $sp, 8\n\n'
        else:
            code += '.text\n'
            code += '\tl.d $f0, 0($sp)\n'
            code += '\tl.d $f2, 8($sp)\n'
            code += '\tsub.d $f4, $f2, $f0\n'
            code += '\ts.d $f4, 8($sp)\n'
            code += '\taddi $sp, $sp, 8\n\n'
        return code

    def mul(self, tree):
        code = ''.join(self.visit_children(tree))
        typ = self.expr_types.pop()
        if typ.name == 'int':
            code += '.text\n'
            code += '\tlw   $t0, 0($sp)\n'
            code += '\tlw   $t1, 8($sp)\n'
            code += '\tmul  $t2, $t1, $t0\n'
            code += '\tsw   $t2, 8($sp)\n'
            code += '\taddi $sp, $sp, 8\n\n'
        if typ.name == 'double':
            code += '.text\n'
            code += '\tl.d      $f0, 0($sp)\n'
            code += '\tl.d      $f2, 8($sp)\n'
            code += '\tmul.d    $f4, $f2, $f0\n'
            code += '\ts.d      $f4, 8($sp)\n'
            code += '\taddi     $sp, $sp, 8\n\n'
        return code

    def div(self, tree):
        code = ''.join(self.visit_children(tree))
        typ = self.expr_types.pop()
        if typ.name == 'int':
            code += '.text\n'
            code += '\tlw $t0, 0($sp)\n'
            code += '\tlw $t1, 8($sp)\n'
            code += '\tdiv $t2, $t1, $t0\n'
            code += '\tsw $t2, 8($sp)\n'
            code += '\taddi $sp, $sp, 8\n\n'
        if typ.name == 'double':
            code += '.text\n'
            code += '\tl.d $f0, 0($sp)\n'
            code += '\tl.d $f2, 8($sp)\n'
            code += '\tdiv.d $f4, $f2, $f0\n'
            code += '\ts.d $f4, 8($sp)\n'
            code += '\taddi $sp, $sp, 8\n\n'
        return code

    def mod(self, tree):
        code = ''.join(self.visit_children(tree))
        code += '.text\n'
        code += '\tlw $t0, 0($sp)\n'
        code += '\tlw $t1, 8($sp)\n'
        code += '\tdiv $t1, $t0\n'
        code += '\tmfhi $t2\n'
        code += '\tsw $t2, 8($sp)\n'
        code += '\taddi $sp, $sp, 8\n'
        self.expr_types.pop()
        return code

    def le(self, tree):
        code = ''.join(self.visit_children(tree))
        typ = self.expr_types.pop()
        if typ.name == 'int':
            code += '.text\n'
            code += '\tlw $t0, 0($sp)\n'
            code += '\tlw $t1, 8($sp)\n'
            code += '\tsle $t2, $t1, $t0\n'
            code += '\tsw $t2, 8($sp)\n'
            code += '\taddi $sp, $sp, 8\n\n'
        if typ.name == 'double':
            label_cnt = cnt()
            code += '.text\n'
            code += '\tli $t0, 0\n'
            code += '\tl.d $f0, 0($sp)\n'
            code += '\tl.d $f2, 8($sp)\n'
            code += '\tc.le.d $f2, $f0\n'
            code += '\tbc1f __double_le__{}\n'.format(label_cnt)
            code += '\tli $t0, 1\n'
            code += '__double_le__{}:\tsw $t0, 8($sp)\n'.format(label_cnt)
            code += '\taddi $sp, $sp, 8\n\n'
        self.expr_types.pop()
        self.expr_types.append(Type('bool'))
        return code

    def lt(self, tree):
        code = ''.join(self.visit_children(tree))
        typ = self.expr_types.pop()
        if typ.name == 'int':
            code += '.text\n'
            code += '\tlw $t0, 0($sp)\n'
            code += '\tlw $t1, 8($sp)\n'
            code += '\tslt $t2, $t1, $t0\n'
            code += '\tsw $t2, 8($sp)\n'
            code += '\taddi $sp, $sp, 8\n\n'
        if typ.name == 'double':
            label_cnt = cnt()
            code += '.text\n'
            code += '\tli $t0, 0\n'
            code += '\tl.d $f0, 0($sp)\n'
            code += '\tl.d $f2, 8($sp)\n'
            code += '\tc.lt.d $f2, $f0\n'
            code += '\tbc1f __double_lt__{}\n'.format(label_cnt)
            code += '\tli $t0, 1\n'
            code += '__double_lt__{}:\tsw $t0, 8($sp)\n'.format(label_cnt)
            code += '\taddi $sp, $sp, 8\n\n'
        self.expr_types.pop()
        self.expr_types.append(Type('bool'))
        return code

    def ge(self, tree):
        code = ''.join(self.visit_children(tree))
        typ = self.expr_types.pop()
        if typ.name == 'int':
            code += '.text\n'
            code += '\tlw $t0, 0($sp)\n'
            code += '\tlw $t1, 8($sp)\n'
            code += '\tsge $t2, $t1, $t0\n'
            code += '\tsw $t2, 8($sp)\n'
            code += '\taddi $sp, $sp, 8\n\n'
        if typ.name == 'double':
            label_cnt = cnt()
            code += '.text\n'
            code += '\tli $t0, 0\n'
            code += '\tl.d $f0, 0($sp)\n'
            code += '\tl.d $f2, 8($sp)\n'
            code += '\tc.lt.d $f2, $f0\n'
            code += '\tbc1t __double_lt__{}\n'.format(label_cnt)
            code += '\tli $t0, 1\n'
            code += '__double_lt__{}:\tsw $t0, 8($sp)\n'.format(label_cnt)
            code += '\taddi $sp, $sp, 8\n\n'
        self.expr_types.pop()
        self.expr_types.append(Type('bool'))
        return code

    def gt(self, tree):
        code = ''.join(self.visit_children(tree))
        typ = self.expr_types.pop()
        if typ.name == 'int':
            code += '.text\n'
            code += '\tlw $t0, 0($sp)\n'
            code += '\tlw $t1, 8($sp)\n'
            code += '\tsgt $t2, $t1, $t0\n'
            code += '\tsw $t2, 8($sp)\n'
            code += '\taddi $sp, $sp, 8\n\n'
        if typ.name == 'double':
            label_cnt = cnt()
            code += '.text\n'
            code += '\tli $t0, 0\n'
            code += '\tl.d $f0, 0($sp)\n'
            code += '\tl.d $f2, 8($sp)\n'
            code += '\tc.le.d $f2, $f0\n'
            code += '\tbc1t __double_gt__{}\n'.format(label_cnt)
            code += '\tli $t0, 1\n'
            code += '__double_gt__{}:\tsw $t0, 8($sp)\n'.format(label_cnt)
            code += '\taddi $sp, $sp, 8\n\n'
        self.expr_types.pop()
        self.expr_types.append(Type('bool'))
        return code

    def eq(self, tree):
        code = ''.join(self.visit_children(tree))
        typ = self.expr_types.pop()
        if typ.name == 'double' and typ.dimension == 0:
            label_cnt = cnt()
            code += '.text\n'
            code += '\tli $t0, 0\n'
            code += '\tl.d $f0, 0($sp)\n'
            code += '\tl.d $f2, 8($sp)\n'
            code += '\tc.eq.d $f0, $f2\n'
            code += '\tbc1f __double_eq__{}\n'.format(label_cnt)
            code += '\tli $t0, 1\n'
            code += '__double_eq__{}:\tsw $t0, 8($sp)\n'.format(label_cnt)
            code += '\taddi $sp, $sp, 8\n\n'
        elif typ.name == 'string' and typ.dimension == 0:
            code += '.text\n'
            code += '\tsw $t0, -8($sp)\n'
            code += '\tsw $t1, -8($sp)\n'
            code += '\tsw $a0, -12($sp)\n'
            code += '\tsw $a1, -16($sp)\n'
            code += '\tsw $v0, -20($sp)\n'
            code += '\tsw $ra, -24($sp)\n'
            code += '\tlw $a0, 0($sp)\n'
            code += '\tlw $a1, 8($sp)\n'
            code += '\tjal __strcmp__\n'
            code += '\tsw $v0, 8($sp)\n'
            code += '\tlw $t0, -4($sp)\n'
            code += '\tlw $t1, -8($sp)\n'
            code += '\tlw $a0, -12($sp)\n'
            code += '\tlw $a1, -16($sp)\n'
            code += '\tlw $v0, -20($sp)\n'
            code += '\tlw $ra, -24($sp)\n'
            code += '\taddi $sp, $sp, 8\n\n'
        elif self:
            code += '.text\n'
            code += '\tlw $t0, 0($sp)\n'
            code += '\tlw $t1, 8($sp)\n'
            code += '\tseq $t2, $t1, $t0\n'
            code += '\tsw $t2, 8($sp)\n'
            code += '\taddi $sp, $sp, 8\n\n'
        self.expr_types.pop()
        self.expr_types.append(Type('bool'))
        return code

    def ne(self, tree):
        code = ''.join(self.visit_children(tree))
        typ = self.expr_types.pop()
        if typ.name == 'double' and typ.dimension == 0:
            label_cnt = cnt()
            code += '.text\n'
            code += '\tli $t0, 0\n'
            code += '\tl.d $f0, 0($sp)\n'
            code += '\tl.d $f2, 8($sp)\n'
            code += '\tc.eq.d $f0, $f2\n'
            code += '\tbc1t __double_ne__{}\n'.format(label_cnt)
            code += '\tli $t0, 1\n'
            code += '__double_ne__{}:\tsw $t0, 8($sp)\n'.format(label_cnt)
            code += '\taddi $sp, $sp, 8\n\n'
        elif typ.name == 'string' and typ.dimension == 0:
            code += '.text\n'
            code += '\tsw $t0, -8($sp)\n'
            code += '\tsw $t1, -8($sp)\n'
            code += '\tsw $a0, -12($sp)\n'
            code += '\tsw $a1, -16($sp)\n'
            code += '\tsw $v0, -20($sp)\n'
            code += '\tsw $ra, -24($sp)\n'
            code += '\tlw $a0, 0($sp)\n'
            code += '\tlw $a1, 8($sp)\n'
            code += '\tjal __strcmp__\n'
            code += '\tli $t0, 1\n'
            code += '\tsub $v0, $t0, $v0\n'
            code += '\tsw $v0, 8($sp)\n'
            code += '\tlw $t0, -4($sp)\n'
            code += '\tlw $t1, -8($sp)\n'
            code += '\tlw $a0, -12($sp)\n'
            code += '\tlw $a1, -16($sp)\n'
            code += '\tlw $v0, -20($sp)\n'
            code += '\tlw $ra, -24($sp)\n'
            code += '\taddi $sp, $sp, 8\n\n'
        elif self:
            code += '.text\n'
            code += '\tlw $t0, 0($sp)\n'
            code += '\tlw $t1, 8($sp)\n'
            code += '\tsne $t2, $t1, $t0\n'
            code += '\tsw $t2, 8($sp)\n'
            code += '\taddi $sp, $sp, 8\n\n'
        self.expr_types.pop()
        self.expr_types.append(Type('bool'))
        return code

    def and_bool(self, tree):
        code = ''.join(self.visit_children(tree))
        code += '.text\n'
        code += '\tlw $t0, 0($sp)\n'
        code += '\tlw $t1, 8($sp)\n'
        code += '\tand $t2, $t1, $t0\n'
        code += '\tsw $t2, 8($sp)\n'
        code += '\taddi $sp, $sp, 8\n\n'
        self.expr_types.pop()
        self.expr_types.pop()
        self.expr_types.append(Type('bool'))
        return code

    def or_bool(self, tree):
        code = ''.join(self.visit_children(tree))
        code += '.text\n'
        code += '\tlw $t0, 0($sp)\n'
        code += '\tlw $t1, 8($sp)\n'
        code += '\tor $t2, $t1, $t0\n'
        code += '\tsw $t2, 8($sp)\n'
        code += '\taddi $sp, $sp, 8\n\n'
        self.expr_types.pop()
        self.expr_types.pop()
        self.expr_types.append(Type(Types.BOOL))
        return code

    def null(self, tree):
        code = '.text\n'
        code += '\tsub $sp, $sp, 8\n'
        code += '\tsw $zero, 0($sp)\n\n'
        self.expr_types.append(Type('null'))
        return code

    def l_value(self, tree):
        return ''.join(self.visit_children(tree))

    def var_addr(self, tree):
        var_scope = self.current_scope
        var_name = tree.children[0].value
        while (var_scope, var_name) not in symbol_table:
            if '__class__' in var_scope.split('/')[-1]:
                class_name = var_scope.split('/')[-1][9:]
                if class_type_objects[class_table[class_name]].find_var_index(var_name) >= 0:
                    break
            var_scope = pop_scope(var_scope)
        if '__class__' in var_scope.split('/')[-1]:
            class_name = var_scope.split('/')[-1][9:]
            class_obj = class_type_objects[class_table[class_name]]
            index = class_obj.find_var_index(var_name)
            if index >= 0:
                function_name = deepcopy(self.current_scope).split('/')
                while function_name[-1] != '_local':
                    function_name.pop()
                function_name.pop()
                # this_label = '/'.join(function_name).replace('/', '_') + '_this'
                code = '.text\n'
                # code += '\tlw $t0, {}\n'.format(this_label)
                # code += '\taddi $t1, $t0, {}\n'.format((1 + index) * 8)
                code += '\tlw $t0, 0($fp)\n'
                code += '\taddi $t1, $t0, {}\n'.format(index * 8 + 8)
                code += '\tsub $sp, $sp, 8\n'
                code += '\tsw $t1, 0($sp)\n'
                self.expr_types.append(deepcopy(class_obj.find_var_type(var_name)))
                return code
        if len(var_scope.split('/')) == 3 and '__class__' in var_scope.split('/')[1]:
            class_name = var_scope.split('/')[1][9:]
            function = class_type_objects[class_table[class_name]].find_function(var_scope.split('/')[-1])
            formal_type, index = function.find_formal(var_name)
            code = '.text\n'
            code += '\taddi $t0, $fp, -{}\n'.format(index * 8)
            code += '\tsub $sp, $sp, 8\n'
            code += '\tsw $t0, 0($sp)\n'
            self.expr_types.append(deepcopy(formal_type[1]))
            return code
        label_name = var_scope.replace('/', '_') + '_' + var_name
        code = '.text\n'
        code += '\tla $t0, {}\n'.format(label_name)
        code += '\tsub $sp, $sp, 8\n'
        code += '\tsw $t0, 0($sp)\n\n'
        typ = symbol_table_objects[symbol_table[var_scope, var_name]].type
        self.expr_types.append(deepcopy(typ))
        return code

    def subscript(self, tree):
        code = ''.join(self.visit_children(tree))
        self.expr_types.pop()
        typ = self.expr_types[-1]
        if typ.name == Types.DOUBLE and typ.dimension == 1:
            code += '.text\n'
            code += '\tlw $t7, 8($sp)\n'
            code += '\tlw $t0, 0($sp)\n'
            # code += '\taddi $t0, $t0, 8\n'
            code += '\tli $t1, 8\n'
            code += '\tmul $t0, $t0, $t1\n'
            code += '\tadd $t1, $t0, $t7\n'
            code += '\tsw $t1, 8($sp)\n'
            code += '\taddi $sp, $sp, 8\n\n'
        else:
            code += '.text\n'
            code += '\tlw $t7, 8($sp)\n'
            code += '\tlw $t0, 0($sp)\n'
            # code += '\taddi $t0, $t0, 8\n'
            code += '\tli $t1, 4\n'
            code += '\tmul $t0, $t0, $t1\n'
            code += '\tadd $t1, $t0, $t7\n'
            code += '\tsw $t1, 8($sp)\n'
            code += '\taddi $sp, $sp, 8\n\n'
        self.expr_types[-1].dimension -= 1
        return code

    def val(self, tree):
        code = ''.join(self.visit_children(tree))
        typ = self.expr_types[-1]
        if typ.name == 'double' and typ.dimension == 0:
            code += '.text\n'
            code += '\tlw $t0, 0($sp)\n'
            code += '\tl.d $f0, 0($t0)\n'
            code += '\ts.d $f0, 0($sp)\n\n'
        else:
            code += '.text\n'
            code += '\tlw $t0, 0($sp)\n'
            code += '\tlw $t0, 0($t0)\n'
            code += '\tsw $t0, 0($sp)\n\n'
        return code

    def ass(self, tree):
        code = ''.join(self.visit_children(tree))
        typ = self.expr_types[-1]
        if typ.name == 'double' and typ.dimension == 0:
            code += '.text\n'
            code += '\tlw $t0, 8($sp)\n'
            code += '\tl.d $f0, 0($sp)\n'
            code += '\ts.d $f0, 0($t0)\n'
            code += '\ts.d $f0, 8($sp)\n'
            code += '\taddi $sp, $sp, 8\n\n'
        else:
            code += '.text\n'
            code += '\tlw $t0, 8($sp)\n'
            code += '\tlw $t1, 0($sp)\n'
            code += '\tsw $t1, 0($t0)\n'
            code += '\tsw $t1, 8($sp)\n'
            code += '\taddi $sp, $sp, 8\n\n'
        self.expr_types.pop()
        return code

    def var_access(self, tree):
        ident = tree.children[1].value
        code = ''
        code += self.visit(tree.children[0])
        code += '.text\n'
        code += '\tlw $t0, 0($sp)\n'

        class_type = self.expr_types[-1]
        # if class_type.dimension > 0:
        #
        #     code += '\tlw $a0, -8($t0)\n'
        #     # code += """
        #     #             addi $a0, $sp, 0
        #     #             li $v0, 1
        #     #             syscall
        #     #             """
        #     code += '\tsw $a0, 0($sp)\n'
        #     self.expr_types.pop()
        #     self.expr_types.append(Type('int)'))
        #     return code

        var_index = class_type_objects[class_table[class_type.name]].find_var_index(ident)
        var_type = class_type_objects[class_table[class_type.name]].find_var_type(ident)

        code += '\taddi $t1, $t0, {}\n'.format((1 + var_index) * 8)
        code += '\tsw $t1, 0($sp)\n'

        self.expr_types.pop()
        self.expr_types.append(var_type)
        return code


def cgen(decaf):
    decaf = tab("""
        int dtoi(double x){
            if(x >= 0)
                return dtoi_(x);
            return -dtoi_(-x);
        }
    """) + decaf
    # decaf = tab("""
    #         int ReadInteger(){
    #             /*
    #
    #             \\n| 10
    #             \\r| 13
    #             +  | 43
    #             -  | 45
    #             x  | 120
    #             X  | 88
    #             0  | 48
    #             9  | 57
    #             A  | 65
    #             F  | 70
    #             a  | 97
    #             f  | 102
    #
    #             */
    #             int res;
    #             int inp;
    #             int sign;
    #             bool hex;
    #             hex = false;
    #             sign = 1;
    #             res = 0;
    #
    #             while(true){
    #                 inp = ReadChar();
    #                 if (inp == 10){
    #                     break;
    #                 }
    #                 if (inp != 43 && inp != 13){
    #                     if (inp == 45){
    #                         sign = -1;
    #                     }else{
    #                         if (inp == 120 || inp == 88){
    #                             hex = true;
    #                         }
    #                         else{
    #                             if(!hex){
    #                                 res = res * 10 + inp - 48;
    #                             }else{
    #                                 if(inp <= 60){
    #                                     inp = inp - 48;
    #                                 }else{
    #                                     if(inp <= 75){
    #                                         inp = inp - 65 + 10;
    #                                     }else{
    #                                         inp = inp - 97 + 10;
    #                                     }
    #                                 }
    #                                 res = res * 16 + inp;
    #                             }
    #                         }
    #                     }
    #                 }
    #             }
    #         return res * sign;
    #     }
    # """) + decaf
    parser = Lark(grammar, parser="lalr")
    parse_tree = parser.parse(decaf)
    SymbolTableMaker().visit(parse_tree)
    ClassTreeSetter().visit(parse_tree)
    set_inheritance()
    ImplicitThis().visit(parse_tree)
    return CodeGenerator().visit(parse_tree)


if __name__ == '__main__':
    decaf = ""
    while True:
        try:
            decaf += input() + "\n"
        except:
            break
    print(cgen(decaf))

